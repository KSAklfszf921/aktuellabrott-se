<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Interaktiv karta √∂ver polish√§ndelser i Sverige - Realtidsdata fr√•n Polisen" />
  <title>Polish√§ndelser Sverige - Interaktiv Realtidskarta</title>

  <!-- External Dependencies -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />

  <style>
    /* Modern CSS Variables - Light Professional Theme */
    :root {
      --color-primary: #475569;
      --color-primary-light: #64748b;
      --color-primary-dark: #334155;
      --color-secondary: #78716c;
      --color-secondary-light: #a8a29e;
      --color-accent: #6b7280;
      --color-warning: #a16207;
      --color-error: #991b1b;
      --color-success: #15803d;

      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-tertiary: #f1f5f9;
      --bg-overlay: rgba(255, 255, 255, 0.95);
      --bg-glass: rgba(255, 255, 255, 0.8);

      --text-primary: #0f172a;
      --text-secondary: #475569;
      --text-muted: #64748b;
      --text-inverse: #ffffff;

      --border-light: #e2e8f0;
      --border-medium: #cbd5e1;
      --border-dark: #94a3b8;

      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);

      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --radius-xl: 16px;

      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;

      --transition-fast: 0.15s ease-out;
      --transition-normal: 0.25s ease-out;
      --transition-slow: 0.4s ease-out;
    }

    /* Reset & Base Styles */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Layout */
    #app {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100vh;
      position: relative;
    }

    /* Header */
    header {
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border-light);
      box-shadow: var(--shadow-sm);
      padding: var(--spacing-md) var(--spacing-lg);
      position: sticky;
      top: 0;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }

    .header-content {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--spacing-md);
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-primary);
      margin: 0;
      letter-spacing: -0.025em;
    }

    .header-subtitle {
      font-size: 0.875rem;
      color: var(--text-secondary);
      margin: 0 0 var(--spacing-md);
      font-weight: 400;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      font-size: 0.75rem;
      color: var(--color-success);
      font-weight: 500;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      background: var(--color-success);
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Controls Grid */
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--spacing-md);
      align-items: start;
    }

    .control-group {
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
      box-shadow: var(--shadow-sm);
      transition: box-shadow var(--transition-fast);
    }

    .control-group:hover {
      box-shadow: var(--shadow-md);
    }

    .control-label {
      display: block;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: var(--spacing-xs);
    }

    /* Form Elements */
    input, select, button {
      font-family: inherit;
      font-size: 0.875rem;
    }

    input[type="text"],
    input[type="number"],
    select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border-medium);
      border-radius: var(--radius-sm);
      background: var(--bg-primary);
      color: var(--text-primary);
      transition: all var(--transition-fast);
      outline: none;
    }

    input:focus,
    select:focus {
      border-color: var(--color-primary-light);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    /* Buttons */
    .button-group {
      display: flex;
      gap: var(--spacing-sm);
      flex-wrap: wrap;
    }

    button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-xs);
      padding: 10px 16px;
      border: 1px solid transparent;
      border-radius: var(--radius-sm);
      font-weight: 500;
      text-decoration: none;
      cursor: pointer;
      transition: all var(--transition-fast);
      position: relative;
      overflow: hidden;
      white-space: nowrap;
    }

    .btn-primary {
      background: var(--color-primary);
      color: var(--text-inverse);
      border-color: var(--color-primary);
    }

    .btn-primary:hover {
      background: var(--color-primary-dark);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .btn-secondary {
      background: var(--bg-primary);
      color: var(--text-secondary);
      border-color: var(--border-medium);
    }

    .btn-secondary:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border-color: var(--border-dark);
    }

    .btn-secondary.active {
      background: var(--color-primary);
      color: var(--text-inverse);
      border-color: var(--color-primary);
    }

    /* Map Container */
    #map {
      width: 100%;
      height: 100%;
      position: relative;
      z-index: 1;
    }

    /* Floating UI Elements */
    .floating-panel {
      position: absolute;
      background: var(--bg-overlay);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      z-index: 500;
      transition: all var(--transition-normal);
    }

    /* Legend */
    .legend {
      bottom: var(--spacing-lg);
      right: var(--spacing-lg);
      padding: var(--spacing-md);
      min-width: 200px;
      max-width: 280px;
    }

    .legend-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0 0 var(--spacing-sm);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .legend-stats {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: var(--spacing-md);
      padding-bottom: var(--spacing-sm);
      border-bottom: 1px solid var(--border-light);
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-xs);
      font-size: 0.75rem;
    }

    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    /* Toast Notifications */
    .toast {
      position: fixed;
      top: var(--spacing-lg);
      right: var(--spacing-lg);
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
      box-shadow: var(--shadow-xl);
      z-index: 2000;
      display: none;
      max-width: 400px;
      font-size: 0.875rem;
      animation: slideIn 0.3s ease-out;
    }

    .toast.success {
      border-left: 4px solid var(--color-success);
    }

    .toast.error {
      border-left: 4px solid var(--color-error);
    }

    .toast.warning {
      border-left: 4px solid var(--color-warning);
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    /* Loading Indicator */
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-overlay);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-lg);
      padding: var(--spacing-xl);
      box-shadow: var(--shadow-xl);
      z-index: 1500;
      display: none;
      text-align: center;
    }

    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border-light);
      border-top: 3px solid var(--color-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto var(--spacing-md);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Enhanced Loading States */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(5px);
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .loading-content {
      text-align: center;
      background: var(--bg-primary);
      padding: var(--spacing-xl);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-xl);
      border: 1px solid var(--border-light);
      max-width: 300px;
      width: 90%;
    }

    .loading-spinner-modern {
      width: 40px;
      height: 40px;
      margin: 0 auto var(--spacing-md);
      position: relative;
    }

    .loading-spinner-modern::before,
    .loading-spinner-modern::after {
      content: '';
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 3px solid transparent;
    }

    .loading-spinner-modern::before {
      border-top-color: var(--color-primary);
      animation: spin 1s linear infinite;
    }

    .loading-spinner-modern::after {
      border-bottom-color: var(--color-primary-light);
      animation: spin 1s linear infinite reverse;
      opacity: 0.5;
    }

    .loading-text {
      font-size: 0.875rem;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .loading-progress {
      width: 100%;
      height: 4px;
      background: var(--bg-tertiary);
      border-radius: 2px;
      margin-top: var(--spacing-md);
      overflow: hidden;
    }

    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--color-primary), var(--color-primary-light));
      border-radius: 2px;
      width: 0%;
      transition: width 0.3s ease;
    }

    /* Skeleton Screens */
    .skeleton-container {
      padding: var(--spacing-md);
    }

    .skeleton {
      background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s infinite;
      border-radius: var(--radius-sm);
    }

    @keyframes skeleton-loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .skeleton-header {
      height: 24px;
      width: 60%;
      margin-bottom: var(--spacing-sm);
    }

    .skeleton-text {
      height: 16px;
      width: 100%;
      margin-bottom: var(--spacing-xs);
    }

    .skeleton-text:last-child {
      width: 75%;
    }

    .skeleton-card {
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
      margin-bottom: var(--spacing-sm);
    }

    .skeleton-circle {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: inline-block;
      margin-right: var(--spacing-sm);
    }

    .skeleton-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-lg);
    }

    .skeleton-stat {
      text-align: center;
    }

    .skeleton-stat-value {
      height: 32px;
      width: 80%;
      margin: 0 auto var(--spacing-xs);
    }

    .skeleton-stat-label {
      height: 16px;
      width: 100%;
    }

    /* Favorites and Bookmarks System */
    .favorites-panel {
      position: fixed;
      top: 100px;
      left: var(--spacing-lg);
      bottom: 100px;
      width: 320px;
      background: var(--bg-overlay);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      z-index: 500;
      display: none;
      flex-direction: column;
      overflow: hidden;
    }

    .favorites-header {
      padding: var(--spacing-md);
      border-bottom: 1px solid var(--border-light);
      background: var(--bg-primary);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .favorites-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
    }

    .favorites-content {
      flex: 1;
      overflow-y: auto;
      padding: var(--spacing-sm);
    }

    .favorites-tabs {
      display: flex;
      margin-bottom: var(--spacing-md);
      background: var(--bg-tertiary);
      border-radius: var(--radius-sm);
      padding: 2px;
    }

    .favorites-tab {
      flex: 1;
      padding: var(--spacing-xs) var(--spacing-sm);
      border: none;
      background: transparent;
      color: var(--text-secondary);
      font-size: 0.8rem;
      font-weight: 500;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .favorites-tab.active {
      background: var(--bg-primary);
      color: var(--text-primary);
      box-shadow: var(--shadow-sm);
    }

    .favorite-item {
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: var(--spacing-sm);
      margin-bottom: var(--spacing-xs);
      cursor: pointer;
      transition: all var(--transition-fast);
      position: relative;
    }

    .favorite-item:hover {
      box-shadow: var(--shadow-md);
      transform: translateY(-1px);
    }

    .favorite-item-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--spacing-xs);
    }

    .favorite-item-type {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .favorite-item-date {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .favorite-item-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
      line-height: 1.3;
    }

    .favorite-item-location {
      font-size: 0.75rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .favorite-item-actions {
      position: absolute;
      top: var(--spacing-xs);
      right: var(--spacing-xs);
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity var(--transition-fast);
    }

    .favorite-item:hover .favorite-item-actions {
      opacity: 1;
    }

    .favorite-action-btn {
      width: 20px;
      height: 20px;
      border: none;
      background: rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      transition: all var(--transition-fast);
    }

    .favorite-action-btn:hover {
      background: var(--color-error);
      color: white;
    }

    .favorite-star-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid var(--border-light);
      border-radius: 50%;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all var(--transition-fast);
      z-index: 10;
    }

    .favorite-star-btn:hover {
      background: var(--color-warning);
      color: white;
      transform: scale(1.1);
    }

    .favorite-star-btn.favorited {
      background: var(--color-warning);
      color: white;
    }

    .favorites-empty {
      text-align: center;
      padding: var(--spacing-xl);
      color: var(--text-muted);
    }

    .favorites-empty-icon {
      font-size: 3rem;
      margin-bottom: var(--spacing-md);
      opacity: 0.5;
    }

    /* Mobile adjustments for favorites */
    @media (max-width: 768px) {
      .favorites-panel {
        left: var(--spacing-sm);
        right: var(--spacing-sm);
        width: auto;
      }
    }

    /* Statistics Panel */
    .stats-panel {
      top: 100px;
      right: var(--spacing-lg);
      bottom: 100px;
      width: 350px;
      padding: var(--spacing-md);
      display: none;
      overflow-y: auto;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--spacing-md);
      padding-bottom: var(--spacing-sm);
      border-bottom: 1px solid var(--border-light);
    }

    .panel-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
    }

    .btn-close {
      width: 32px;
      height: 32px;
      padding: 0;
      border-radius: 50%;
      background: transparent;
      border: 1px solid var(--border-light);
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    .btn-close:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    /* Chart Container */
    .chart-container {
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
      margin-bottom: var(--spacing-md);
    }

    /* Floating Action Buttons */
    .fab-container {
      position: absolute;
      top: var(--spacing-lg);
      right: var(--spacing-lg);
      z-index: 600;
      display: flex;
      gap: var(--spacing-sm);
    }

    .fab {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      box-shadow: var(--shadow-md);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all var(--transition-fast);
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .fab:hover {
      background: var(--color-primary);
      color: var(--text-inverse);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    /* Timeline Controls */
    .timeline-controls {
      position: absolute;
      bottom: var(--spacing-lg);
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-overlay);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-lg);
      padding: var(--spacing-md);
      box-shadow: var(--shadow-lg);
      display: none;
      min-width: 400px;
      z-index: 600;
    }

    .timeline-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--spacing-md);
    }

    .timeline-slider {
      width: 100%;
      margin: var(--spacing-sm) 0;
    }

    .timeline-time {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-primary);
      text-align: center;
    }

    /* Responsive Design */
    @media (max-width: 1024px) {
      .legend {
        bottom: var(--spacing-sm);
        right: var(--spacing-sm);
        max-width: 240px;
      }

      .stats-panel {
        width: 300px;
        right: var(--spacing-sm);
      }

      .fab-container {
        top: var(--spacing-sm);
        right: var(--spacing-sm);
      }
    }

    @media (max-width: 768px) {
      header {
        padding: var(--spacing-sm) var(--spacing-md);
      }

      .header-title {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--spacing-sm);
      }

      h1 {
        font-size: 1.25rem;
      }

      .header-subtitle {
        font-size: 0.8rem;
        margin-bottom: var(--spacing-sm);
      }

      .controls {
        grid-template-columns: 1fr;
        gap: var(--spacing-sm);
      }

      .control-group {
        padding: var(--spacing-sm) var(--spacing-md);
      }

      .button-group {
        justify-content: stretch;
        flex-direction: column;
      }

      .button-group button {
        flex: 1;
        min-width: 0;
        padding: 12px 16px;
        font-size: 0.9rem;
        min-height: 44px; /* Better touch target */
      }

      /* Enhanced mobile form elements */
      input[type="text"],
      input[type="number"],
      select {
        padding: 12px 16px;
        font-size: 16px; /* Prevents zoom on iOS */
        min-height: 44px;
        border-radius: var(--radius-md);
      }

      .stats-panel {
        width: calc(100vw - 2 * var(--spacing-sm));
        right: var(--spacing-sm);
        left: var(--spacing-sm);
        max-height: 60vh;
        overflow-y: auto;
      }

      .timeline-controls {
        min-width: calc(100vw - 2 * var(--spacing-sm));
        left: var(--spacing-sm);
        right: var(--spacing-sm);
        transform: none;
        padding: var(--spacing-md);
      }

      .fab-container {
        flex-direction: column;
        bottom: calc(var(--spacing-lg) + 60px); /* Account for mobile browser bars */
      }

      .fab {
        width: 48px;
        height: 48px;
        font-size: 1.1rem;
      }

      .legend {
        bottom: var(--spacing-sm);
        right: var(--spacing-sm);
        left: var(--spacing-sm);
        max-width: none;
        width: calc(100vw - 2 * var(--spacing-sm));
      }

      /* Mobile popup improvements */
      .leaflet-popup-content-wrapper {
        max-width: calc(100vw - 40px) !important;
        border-radius: var(--radius-lg) !important;
      }

      .leaflet-popup-content {
        font-size: 0.875rem !important;
        line-height: 1.5 !important;
        margin: var(--spacing-md) !important;
      }
    }

    /* Small mobile devices */
    @media (max-width: 480px) {
      .header-content {
        padding: 0;
      }

      h1 {
        font-size: 1.1rem;
      }

      .header-subtitle {
        font-size: 0.75rem;
      }

      .control-group {
        padding: var(--spacing-sm);
      }

      .button-group button {
        font-size: 0.85rem;
        padding: 10px 12px;
      }
    }

    /* Map Marker Animations */
    .crime-marker {
      transition: all var(--transition-fast);
    }

    .crime-marker:hover {
      transform: scale(1.1);
    }

    .exact-location {
      animation: pulseExact 2s infinite;
    }

    .approximate-location {
      animation: pulseApprox 3s infinite;
    }

    @keyframes pulseExact {
      0%, 100% { opacity: 0.9; }
      50% { opacity: 1; }
    }

    @keyframes pulseApprox {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 0.85; }
    }

    /* Custom Leaflet Popup Styling */
    .leaflet-popup-content-wrapper {
      background: var(--bg-primary);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-xl);
      border: 1px solid var(--border-light);
    }

    .leaflet-popup-content {
      margin: 0;
      font-family: inherit;
      font-size: 0.875rem;
      line-height: 1.5;
      color: var(--text-primary);
    }

    .leaflet-popup-tip {
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-top: none;
      border-right: none;
    }

    /* Accessibility */
    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* Focus Styles */
    button:focus-visible,
    input:focus-visible,
    select:focus-visible {
      outline: 2px solid var(--color-primary);
      outline-offset: 2px;
    }

    /* Print Styles */
    @media print {
      .floating-panel,
      .fab-container,
      .timeline-controls,
      .toast {
        display: none !important;
      }

      header {
        position: static;
        box-shadow: none;
      }
    }
  </style>
</head>

<body>
  <div id="app">
    <header>
      <div class="header-content">
        <div class="header-title">
          <div>
            <h1>Polish√§ndelser Sverige</h1>
            <p class="header-subtitle">Interaktiv realtidskarta med de senaste polish√§ndelserna och alla polisstationer</p>
          </div>
          <div class="status-indicator">
            <div class="status-dot"></div>
            <span>Live-data</span>
          </div>
        </div>

        <div class="controls">
          <div class="control-group">
            <label class="control-label" for="max-events">Max h√§ndelser</label>
            <input
              id="max-events"
              type="number"
              min="50"
              max="1000"
              value="500"
              step="50"
              aria-label="Maximalt antal h√§ndelser att visa"
            >
          </div>

          <div class="control-group">
            <label class="control-label" for="event-type">H√§ndelsetyp</label>
            <select id="event-type" multiple aria-label="Filtrera efter h√§ndelsetyp">
              <!-- Dynamically populated -->
            </select>
          </div>

          <div class="control-group">
            <label class="control-label" for="search-query">S√∂k h√§ndelser</label>
            <input
              id="search-query"
              type="text"
              placeholder="S√∂k efter plats, typ eller beskrivning..."
              aria-label="S√∂k h√§ndelser"
            >
          </div>

          <div class="control-group">
            <label class="control-label" for="date-from">Datumfilter</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--spacing-xs);">
              <input
                id="date-from"
                type="date"
                aria-label="Fr√•n datum"
                style="font-size: 0.8rem;"
              >
              <input
                id="date-to"
                type="date"
                aria-label="Till datum"
                style="font-size: 0.8rem;"
              >
            </div>
          </div>

          <div class="control-group">
            <label class="control-label" for="location-search">Platsfilter</label>
            <div style="display: flex; gap: var(--spacing-xs);">
              <input
                id="location-search"
                type="text"
                placeholder="Plats eller postnummer..."
                aria-label="S√∂k efter plats"
                style="flex: 1;"
              >
              <select id="distance-radius" aria-label="V√§lj radie" style="width: 100px; font-size: 0.8rem;">
                <option value="5">5 km</option>
                <option value="10" selected>10 km</option>
                <option value="25">25 km</option>
                <option value="50">50 km</option>
                <option value="100">100 km</option>
              </select>
            </div>
            <div style="margin-top: var(--spacing-xs);">
              <button id="use-current-location" class="btn-secondary" style="font-size: 0.75rem; padding: 6px 12px;">
                üìç Anv√§nd min position
              </button>
            </div>
          </div>

          <div class="control-group">
            <label class="control-label">Snabbfilter</label>
            <div class="button-group" style="flex-wrap: wrap;">
              <button id="filter-today" class="btn-secondary" style="font-size: 0.75rem; padding: 6px 12px;">
                Idag
              </button>
              <button id="filter-week" class="btn-secondary" style="font-size: 0.75rem; padding: 6px 12px;">
                Denna vecka
              </button>
              <button id="filter-high-priority" class="btn-secondary" style="font-size: 0.75rem; padding: 6px 12px;">
                H√∂gprioriterade
              </button>
              <button id="filter-clear" class="btn-secondary" style="font-size: 0.75rem; padding: 6px 12px;">
                Rensa filter
              </button>
            </div>
          </div>

          <div class="control-group">
            <label class="control-label">Visningsl√§ge</label>
            <div class="button-group">
              <button id="view-markers" class="btn-secondary active" aria-label="Visa som mark√∂rer">
                Mark√∂rer
              </button>
              <button id="view-heatmap" class="btn-secondary" aria-label="Visa som v√§rmekarta">
                V√§rmekarta
              </button>
            </div>
          </div>

          <div class="control-group">
            <label class="control-label">Funktioner</label>
            <div class="button-group">
              <button id="locate-user" class="btn-secondary" aria-label="Visa min position">
                Min position
              </button>
              <button id="favorites-toggle" class="btn-secondary" aria-label="Visa favoriter">
                ‚≠ê Favoriter
              </button>
              <button id="timeline-toggle" class="btn-secondary" aria-label="Visa tidslinje">
                Tidslinje
              </button>
              <button id="refresh-data" class="btn-primary" aria-label="Uppdatera data">
                Uppdatera
              </button>
            </div>
          </div>
        </div>
      </div>
    </header>

    <main id="map" role="main" aria-label="Interaktiv karta √∂ver polish√§ndelser"></main>
  </div>

  <!-- Floating Action Buttons -->
  <div class="fab-container">
    <button class="fab" id="fullscreen-toggle" aria-label="Fullsk√§rm" title="Fullsk√§rmsl√§ge">
      ‚õ∂
    </button>
    <button class="fab" id="stats-toggle" aria-label="Statistik" title="Visa statistik">
      üìä
    </button>
  </div>

  <!-- Legend -->
  <div class="legend floating-panel" id="legend">
    <h3 class="legend-title">
      √ñversikt
      <button class="btn-close" id="legend-close" aria-label="St√§ng legend">√ó</button>
    </h3>
    <div class="legend-stats" id="legend-stats">
      Laddar statistik...
    </div>
    <div id="legend-items">
      <!-- Dynamically populated -->
    </div>
  </div>

  <!-- Favorites Panel -->
  <div class="favorites-panel" id="favorites-panel">
    <div class="favorites-header">
      <h3 class="favorites-title">Mina Favoriter</h3>
      <button class="btn-close" id="favorites-close" aria-label="St√§ng favoritpanel">√ó</button>
    </div>
    <div class="favorites-content">
      <div class="favorites-tabs">
        <button class="favorites-tab active" id="tab-events" data-tab="events">
          H√§ndelser <span id="favorites-count-events">(0)</span>
        </button>
        <button class="favorites-tab" id="tab-locations" data-tab="locations">
          Platser <span id="favorites-count-locations">(0)</span>
        </button>
      </div>
      <div id="favorites-events-content">
        <div class="favorites-empty" id="favorites-events-empty">
          <div class="favorites-empty-icon">‚≠ê</div>
          <div>Inga sparade h√§ndelser √§n</div>
          <div style="font-size: 0.8rem; margin-top: var(--spacing-xs); opacity: 0.7;">
            Klicka p√• stj√§rnans ikon vid h√§ndelser f√∂r att spara dem
          </div>
        </div>
      </div>
      <div id="favorites-locations-content" style="display: none;">
        <div class="favorites-empty" id="favorites-locations-empty">
          <div class="favorites-empty-icon">üìç</div>
          <div>Inga sparade platser √§n</div>
          <div style="font-size: 0.8rem; margin-top: var(--spacing-xs); opacity: 0.7;">
            Spara intressanta platser genom att s√∂ka efter dem
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Statistics Panel -->
  <div class="stats-panel floating-panel" id="stats-panel">
    <div class="panel-header">
      <h2 class="panel-title">Detaljerad Statistik</h2>
      <button class="btn-close" id="stats-close" aria-label="St√§ng statistikpanel">√ó</button>
    </div>

    <div class="chart-container">
      <h4 style="margin: 0 0 16px; color: var(--text-primary);">H√§ndelser √∂ver tid</h4>
      <canvas id="timeline-chart" width="300" height="150"></canvas>
    </div>

    <div class="chart-container">
      <h4 style="margin: 0 0 16px; color: var(--text-primary);">Typ av h√§ndelser</h4>
      <canvas id="type-chart" width="300" height="150"></canvas>
    </div>

    <div id="rss-container">
      <h4 style="margin: 0 0 16px; color: var(--text-primary);">Senaste nyheterna</h4>
      <input
        id="rss-filter"
        type="text"
        placeholder="Filtrera nyheter..."
        style="width: 100%; margin-bottom: 16px; padding: 8px 12px; border: 1px solid var(--border-medium); border-radius: var(--radius-sm);"
      >
      <div id="rss-items">
        <!-- Dynamically populated -->
      </div>
    </div>
  </div>

  <!-- Timeline Controls -->
  <div class="timeline-controls floating-panel" id="timeline-panel">
    <div class="timeline-header">
      <h3 style="margin: 0; font-size: 0.875rem; color: var(--text-primary);">Tidslinje-uppspelning</h3>
      <div style="display: flex; gap: 8px;">
        <button id="timeline-play" class="btn-secondary">Spela</button>
        <button id="timeline-pause" class="btn-secondary">Pausa</button>
        <button id="timeline-close" class="btn-close">√ó</button>
      </div>
    </div>
    <input
      type="range"
      id="timeline-slider"
      class="timeline-slider"
      min="0"
      max="23"
      value="0"
      aria-label="Tidslinje f√∂r timme p√• dagen"
    >
    <div class="timeline-time" id="timeline-time">00:00</div>
  </div>

  <!-- Toast Notifications -->
  <div class="toast" id="toast" role="alert" aria-live="polite">
    <!-- Dynamically populated -->
  </div>

  <!-- Loading Indicator -->
  <div class="loading" id="loading">
    <div class="spinner"></div>
    <div id="loading-text">Laddar data...</div>
  </div>

  <!-- Enhanced Loading Overlay -->
  <div class="loading-overlay" id="loading-overlay">
    <div class="loading-content">
      <div class="loading-spinner-modern"></div>
      <div class="loading-text" id="loading-overlay-text">Laddar polisdata...</div>
      <div class="loading-progress" id="loading-progress" style="display: none;">
        <div class="loading-progress-bar" id="loading-progress-bar"></div>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="js/enhanced-popup.js"></script>

  <script>
    'use strict';

    // ===== UTILITY FUNCTIONS =====
    class Utils {
      // Toast notifications with better UX
      static showToast(message, duration = 3000, type = 'info') {
        const toast = document.getElementById('toast');
        const existingTimer = toast._timer;

        if (existingTimer) {
          clearTimeout(existingTimer);
        }

        toast.textContent = message;
        toast.className = `toast ${type}`;
        toast.style.display = 'block';

        toast._timer = setTimeout(() => {
          toast.style.display = 'none';
          toast._timer = null;
        }, duration);
      }

      // Loading state management
      static showLoading(text = 'Laddar...') {
        document.getElementById('loading-text').textContent = text;
        document.getElementById('loading').style.display = 'block';
      }

      static hideLoading() {
        document.getElementById('loading').style.display = 'none';
      }

      // Enhanced loading with progress
      static showLoadingOverlay(text = 'Laddar...', showProgress = false) {
        document.getElementById('loading-overlay-text').textContent = text;
        document.getElementById('loading-overlay').style.display = 'flex';

        const progressContainer = document.getElementById('loading-progress');
        const progressBar = document.getElementById('loading-progress-bar');

        if (showProgress) {
          progressContainer.style.display = 'block';
          progressBar.style.width = '0%';
        } else {
          progressContainer.style.display = 'none';
        }
      }

      static updateLoadingProgress(percentage, text = null) {
        const progressBar = document.getElementById('loading-progress-bar');
        const textElement = document.getElementById('loading-overlay-text');

        progressBar.style.width = Math.min(100, Math.max(0, percentage)) + '%';

        if (text) {
          textElement.textContent = text;
        }
      }

      static hideLoadingOverlay() {
        document.getElementById('loading-overlay').style.display = 'none';
      }

      // Skeleton screen methods
      static showSkeleton(containerId, type = 'default') {
        const container = document.getElementById(containerId);
        if (!container) return;

        const skeletonHTML = this.generateSkeletonHTML(type);
        container.innerHTML = skeletonHTML;
        container.classList.add('skeleton-container');
      }

      static hideSkeleton(containerId) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.classList.remove('skeleton-container');
        // Content will be replaced by actual data
      }

      static generateSkeletonHTML(type) {
        switch (type) {
          case 'stats':
            return `
              <div class="skeleton-stats">
                <div class="skeleton-stat">
                  <div class="skeleton skeleton-stat-value"></div>
                  <div class="skeleton skeleton-stat-label"></div>
                </div>
                <div class="skeleton-stat">
                  <div class="skeleton skeleton-stat-value"></div>
                  <div class="skeleton skeleton-stat-label"></div>
                </div>
                <div class="skeleton-stat">
                  <div class="skeleton skeleton-stat-value"></div>
                  <div class="skeleton skeleton-stat-label"></div>
                </div>
                <div class="skeleton-stat">
                  <div class="skeleton skeleton-stat-value"></div>
                  <div class="skeleton skeleton-stat-label"></div>
                </div>
              </div>
            `;

          case 'events':
            return Array.from({ length: 5 }, () => `
              <div class="skeleton-card">
                <div style="display: flex; align-items: center; margin-bottom: var(--spacing-sm);">
                  <div class="skeleton skeleton-circle"></div>
                  <div style="flex: 1;">
                    <div class="skeleton skeleton-header"></div>
                  </div>
                </div>
                <div class="skeleton skeleton-text"></div>
                <div class="skeleton skeleton-text"></div>
                <div class="skeleton skeleton-text"></div>
              </div>
            `).join('');

          case 'legend':
            return Array.from({ length: 8 }, () => `
              <div style="display: flex; align-items: center; margin-bottom: var(--spacing-xs);">
                <div class="skeleton skeleton-circle" style="width: 12px; height: 12px;"></div>
                <div class="skeleton skeleton-text" style="margin-left: var(--spacing-sm); width: 120px; height: 12px;"></div>
              </div>
            `).join('');

          default:
            return `
              <div class="skeleton-card">
                <div class="skeleton skeleton-header"></div>
                <div class="skeleton skeleton-text"></div>
                <div class="skeleton skeleton-text"></div>
                <div class="skeleton skeleton-text"></div>
              </div>
            `;
        }
      }

      // Debounce function for performance
      static debounce(func, delay) {
        let timeoutId;
        return (...args) => {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => func.apply(null, args), delay);
        };
      }

      // Throttle function for performance
      static throttle(func, delay) {
        let lastCall = 0;
        return (...args) => {
          const now = Date.now();
          if (now - lastCall >= delay) {
            lastCall = now;
            func.apply(null, args);
          }
        };
      }

      // Enhanced fetch with retry logic
      static async fetchWithRetry(url, options = {}, maxRetries = 3) {
        let lastError;

        for (let i = 0; i < maxRetries; i++) {
          try {
            const response = await fetch(url, options);

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            return response;
          } catch (error) {
            lastError = error;

            if (i < maxRetries - 1) {
              // Exponential backoff
              const delay = Math.min(1000 * Math.pow(2, i), 5000);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        }

        throw lastError;
      }

      // Safe JSON parsing
      static async safeJsonParse(response) {
        const text = await response.text();
        try {
          return JSON.parse(text);
        } catch (error) {
          throw new Error(`Invalid JSON response: ${error.message}`);
        }
      }

      // Sanitize HTML to prevent XSS
      static sanitizeHTML(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
      }

      // Format date in Swedish locale
      static formatDate(date, options = {}) {
        return new Intl.DateTimeFormat('sv-SE', {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          ...options
        }).format(date);
      }

      // Generate stable ID from object
      static generateStableId(obj) {
        const str = JSON.stringify(obj, Object.keys(obj).sort());
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32-bit integer
        }
        return `id_${Math.abs(hash).toString(36)}`;
      }
    }

    // ===== CRIME SEVERITY SYSTEM =====
    class CrimeSeveritySystem {
      static SEVERITY_MAPPING = {
        // Level 1 - Minor offenses (Muted Green)
        'Trafikbrott': { level: 1, color: '#6b7280', description: 'Trafikbrott' },
        'Fortk√∂rning': { level: 1, color: '#6b7280', description: 'Fortk√∂rning' },
        'Parkering': { level: 1, color: '#6b7280', description: 'Parkeringsbrott' },
        'Ordningslagen': { level: 1, color: '#6b7280', description: 'Ordningslagen' },

        // Level 2 - Property crimes (Muted Yellow-Orange)
        'Skadeg√∂relse': { level: 2, color: '#a16207', description: 'Skadeg√∂relse' },
        'St√∂ld': { level: 2, color: '#92400e', description: 'St√∂ld' },
        'Snatteri': { level: 2, color: '#92400e', description: 'Snatteri' },
        'Bedr√§geri': { level: 2, color: '#92400e', description: 'Bedr√§geri' },
        'Inbrott': { level: 2, color: '#78350f', description: 'Inbrott' },

        // Level 3 - Drug crimes and serious property crimes (Muted Orange-Red)
        'Narkotikabrott': { level: 3, color: '#a16207', description: 'Narkotikabrott' },
        'Rattfylleri': { level: 3, color: '#a16207', description: 'Rattfylleri' },
        'R√•n': { level: 3, color: '#92400e', description: 'R√•n' },

        // Level 4 - Violent crimes (Muted Red)
        'Misshandel': { level: 4, color: '#7c2d12', description: 'Misshandel' },
        'V√•ldt√§kt': { level: 4, color: '#7c2d12', description: 'V√•ldt√§kt' },
        'V√•ld mot tj√§nsteman': { level: 4, color: '#7c2d12', description: 'V√•ld mot tj√§nsteman' },
        'Olaga hot': { level: 4, color: '#7c2d12', description: 'Olaga hot' },

        // Level 5 - Most serious crimes (Dark Muted Red)
        'Mord': { level: 5, color: '#78716c', description: 'Mord' },
        'Dr√•p': { level: 5, color: '#78716c', description: 'Dr√•p' },
        'Mordbrand': { level: 5, color: '#78716c', description: 'Mordbrand' },
        'Brand': { level: 4, color: '#7c2d12', description: 'Brand' },

        // Default
        '√ñvrigt': { level: 2, color: '#6b7280', description: '√ñvrigt' }
      };

      static getSeverityInfo(crimeType) {
        // Direct match
        if (this.SEVERITY_MAPPING[crimeType]) {
          return this.SEVERITY_MAPPING[crimeType];
        }

        // Fuzzy matching for similar crime types
        const lowerType = crimeType.toLowerCase();

        for (const [key, value] of Object.entries(this.SEVERITY_MAPPING)) {
          if (lowerType.includes(key.toLowerCase()) || key.toLowerCase().includes(lowerType)) {
            return value;
          }
        }

        // Check for partial matches with common crime terms
        const crimeKeywords = {
          'st√∂ld': this.SEVERITY_MAPPING['St√∂ld'],
          'inbrott': this.SEVERITY_MAPPING['Inbrott'],
          'r√•n': this.SEVERITY_MAPPING['R√•n'],
          'misshandel': this.SEVERITY_MAPPING['Misshandel'],
          'narkotika': this.SEVERITY_MAPPING['Narkotikabrott'],
          'trafik': this.SEVERITY_MAPPING['Trafikbrott'],
          'brand': this.SEVERITY_MAPPING['Brand'],
          'v√•ld': this.SEVERITY_MAPPING['Misshandel']
        };

        for (const [keyword, severity] of Object.entries(crimeKeywords)) {
          if (lowerType.includes(keyword)) {
            return severity;
          }
        }

        // Default fallback
        return this.SEVERITY_MAPPING['√ñvrigt'];
      }

      static getSeverityColor(crimeType) {
        return this.getSeverityInfo(crimeType).color;
      }

      static getSeverityLevel(crimeType) {
        return this.getSeverityInfo(crimeType).level;
      }

      static getAllSeverityLevels() {
        const levels = {};
        Object.values(this.SEVERITY_MAPPING).forEach(info => {
          if (!levels[info.level]) {
            levels[info.level] = [];
          }
          levels[info.level].push(info);
        });
        return levels;
      }
    }

    // ===== DATA MODELS =====
    class PoliceEvent {
      constructor(rawData) {
        this.id = Utils.generateStableId(rawData);
        this.rawData = rawData;
        this.parseData();
      }

      parseData() {
        const raw = this.rawData;

        // Parse coordinates
        this.parseCoordinates();

        // Parse date/time
        this.parseDateTime();

        // Extract location information
        this.parseLocation();

        // Parse event details
        this.type = raw.type || 'Ok√§nd h√§ndelse';
        this.title = raw.name || raw.title || this.type;
        this.description = raw.summary || raw.description || '';
        this.url = raw.url || null;

        // Determine location accuracy
        this.exactLocation = this.hasExactCoordinates();

        // Get severity information
        this.severityInfo = CrimeSeveritySystem.getSeverityInfo(this.type);
      }

      parseCoordinates() {
        const raw = this.rawData;
        let lat = null, lng = null;

        // Try different coordinate formats
        if (raw.location && raw.location.gps) {
          const gps = raw.location.gps;
          if (typeof gps === 'string') {
            const coords = gps.split(',').map(c => parseFloat(c.trim()));
            if (coords.length === 2 && !isNaN(coords[0]) && !isNaN(coords[1])) {
              [lat, lng] = coords;
            }
          } else if (gps.lat && gps.lng) {
            lat = parseFloat(gps.lat);
            lng = parseFloat(gps.lng);
          }
        }

        // Validate coordinates are within Sweden's bounds
        if (lat && lng && this.isWithinSweden(lat, lng)) {
          this.lat = lat;
          this.lng = lng;
        } else {
          this.lat = null;
          this.lng = null;
        }
      }

      parseDateTime() {
        const raw = this.rawData;
        const dateStr = raw.datetime || raw.pubDate || raw.date;

        if (dateStr) {
          this.timestamp = new Date(dateStr);
          if (isNaN(this.timestamp)) {
            // Try alternative parsing
            this.timestamp = new Date();
          }
        } else {
          this.timestamp = new Date();
        }

        this.timeMs = this.timestamp.getTime();
      }

      parseLocation() {
        const raw = this.rawData;

        // Extract city/location name
        this.city = raw.location?.name || 'Ok√§nd plats';

        // Try to extract address from description or summary
        this.address = this.extractAddress() || this.city;

        // Apply random offset if no exact location (privacy/accuracy)
        if (!this.hasExactCoordinates() && this.lat && this.lng) {
          this.applyRandomOffset();
        }
      }

      extractAddress() {
        const text = (this.description + ' ' + this.title).toLowerCase();

        // Swedish address patterns
        const patterns = [
          /(?:vid|p√•|i|fr√•n)\s+([A-Z√Ö√Ñ√ñ][a-z√•√§√∂]+(?:gatan|v√§gen|torget|platsen|parken))/i,
          /(?:vid|p√•|i|fr√•n)\s+([A-Z√Ö√Ñ√ñ][a-z√•√§√∂]+\s+\d+)/i,
          /(\w+gatan\s+\d+)/i,
          /(\w+v√§gen\s+\d+)/i
        ];

        for (const pattern of patterns) {
          const match = text.match(pattern);
          if (match) {
            return match[1];
          }
        }

        return null;
      }

      hasExactCoordinates() {
        const text = (this.description + ' ' + this.title).toLowerCase();

        // Indicators of exact location
        const exactIndicators = ['gatan', 'v√§gen', 'torget', 'platsen', 'nummer'];
        const approximateIndicators = ['omr√•det', 'n√§rheten', 'cirka', 'ungef√§r'];

        const hasExact = exactIndicators.some(ind => text.includes(ind));
        const hasApproximate = approximateIndicators.some(ind => text.includes(ind));

        return hasExact && !hasApproximate;
      }

      applyRandomOffset() {
        if (!this.lat || !this.lng) return;

        // Add random offset up to ~500 meters
        const offsetLat = (Math.random() - 0.5) * 0.008; // ~0.4km
        const offsetLng = (Math.random() - 0.5) * 0.012; // ~0.4km

        this.lat += offsetLat;
        this.lng += offsetLng;
      }

      isWithinSweden(lat, lng) {
        // Sweden's approximate bounds
        return lat >= 55.0 && lat <= 69.1 && lng >= 10.5 && lng <= 24.2;
      }

      isValidEvent() {
        return this.lat && this.lng && this.timestamp && this.type;
      }

      getFormattedTime() {
        return Utils.formatDate(this.timestamp);
      }

      getPopupContent() {
        const severityColor = this.severityInfo.color;
        const locationAccuracy = this.exactLocation ?
          '<span style="color: var(--color-success); font-size: 0.75rem; font-weight: 500;">üìç Exakt position</span>' :
          '<span style="color: var(--color-warning); font-size: 0.75rem; font-weight: 500;">üìç Ungef√§rlig position</span>';

        const fullAddress = this.address !== this.city ? this.address : this.city;

        return `
          <div style="min-width: 260px; font-family: inherit; line-height: 1.5;">
            <h3 style="margin: 0 0 12px; color: var(--text-primary); font-size: 1rem; border-bottom: 2px solid ${severityColor}; padding-bottom: 6px;">
              ${Utils.sanitizeHTML(this.title)}
            </h3>

            <div style="margin: 8px 0; padding: 8px 12px; background: var(--bg-tertiary); border-left: 3px solid ${severityColor}; border-radius: 4px;">
              <strong style="color: var(--text-primary); font-size: 0.875rem;">
                ${Utils.sanitizeHTML(this.severityInfo.description)}
              </strong>
            </div>

            <div style="margin: 12px 0;">
              <strong style="color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em;">
                Plats:
              </strong><br/>
              <span style="color: var(--text-primary); font-size: 0.875rem;">
                ${Utils.sanitizeHTML(fullAddress)}
              </span><br/>
              ${locationAccuracy}
            </div>

            <div style="margin: 12px 0;">
              <strong style="color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em;">
                Tid:
              </strong><br/>
              <span style="color: var(--text-primary); font-size: 0.875rem;">
                ${this.getFormattedTime()}
              </span>
            </div>

            ${this.description ? `
              <div style="margin: 12px 0; padding-top: 8px; border-top: 1px solid var(--border-light);">
                <div style="color: var(--text-secondary); font-size: 0.8rem;">
                  ${Utils.sanitizeHTML(this.description)}
                </div>
              </div>
            ` : ''}

            ${this.url ? `
              <div style="margin: 12px 0; padding-top: 8px; border-top: 1px solid var(--border-light);">
                <a href="${this.url}" target="_blank" style="color: var(--color-primary); text-decoration: none; font-size: 0.875rem; font-weight: 500;">
                  Mer information ‚Üí
                </a>
              </div>
            ` : ''}
          </div>
        `;
      }
    }

    class PoliceStation {
      constructor(rawData) {
        this.id = Utils.generateStableId(rawData);
        this.rawData = rawData;
        this.parseData();
      }

      parseData() {
        const raw = this.rawData;

        this.name = raw.name || 'Polisstation';
        this.parseCoordinates();
        this.parseContactInfo();
        this.parseServices();
      }

      parseCoordinates() {
        const raw = this.rawData;
        let lat = null, lng = null;

        const location = raw.location;
        if (location) {
          const gps = location.gps || location.position || location.coordinates;

          if (typeof gps === 'string') {
            const coords = gps.split(',').map(c => parseFloat(c.trim()));
            if (coords.length === 2 && !isNaN(coords[0]) && !isNaN(coords[1])) {
              [lat, lng] = coords;
            }
          } else if (gps && typeof gps === 'object') {
            lat = gps.lat || gps.y;
            lng = gps.lng || gps.lon || gps.x;
          }
        }

        this.lat = lat;
        this.lng = lng;
      }

      parseContactInfo() {
        const raw = this.rawData;

        this.address = raw.location?.name || raw.location?.address || 'Adress ej tillg√§nglig';
        this.phone = raw.phone || raw.contact?.phone || '';
        this.email = raw.email || raw.contact?.email || '';
        this.website = raw.url || raw.Url || raw.location?.url || null;
        this.openingHours = raw.openingHours || raw.hours || '';
      }

      parseServices() {
        const raw = this.rawData;
        this.services = Array.isArray(raw.services) ? raw.services : [];
        this.servicesText = this.services.length > 0 ? this.services.join(', ') : 'Allm√§nna polistj√§nster';
      }

      isValidStation() {
        return this.lat && this.lng && this.name;
      }

      createMarker() {
        if (!this.isValidStation()) return null;

        const icon = L.divIcon({
          className: 'police-station-icon',
          html: '<div style="background: var(--color-secondary); border: 2px solid white; border-radius: 50%; width: 10px; height: 10px; box-shadow: var(--shadow-sm);"></div>',
          iconSize: [10, 10],
          iconAnchor: [5, 5]
        });

        const marker = L.marker([this.lat, this.lng], {
          icon: icon,
          zIndexOffset: 100 // Below crime events
        });

        marker.bindPopup(this.getPopupContent(), {
          maxWidth: 320,
          className: 'police-station-popup'
        });

        return marker;
      }

      getPopupContent() {
        return `
          <div style="min-width: 240px; font-family: inherit; line-height: 1.5;">
            <h3 style="margin: 0 0 12px; color: var(--text-primary); font-size: 1rem; border-bottom: 2px solid var(--color-primary); padding-bottom: 6px;">
              üè¢ ${Utils.sanitizeHTML(this.name)}
            </h3>

            <div style="margin: 12px 0;">
              <strong style="color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em;">
                Adress:
              </strong><br/>
              <span style="color: var(--text-primary); font-size: 0.875rem;">
                ${Utils.sanitizeHTML(this.address)}
              </span>
            </div>

            <div style="margin: 12px 0;">
              <strong style="color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em;">
                Tj√§nster:
              </strong><br/>
              <span style="color: var(--text-primary); font-size: 0.875rem;">
                ${Utils.sanitizeHTML(this.servicesText)}
              </span>
            </div>

            ${this.phone ? `
              <div style="margin: 12px 0;">
                <strong style="color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em;">
                  Telefon:
                </strong><br/>
                <a href="tel:${this.phone}" style="color: var(--color-primary); text-decoration: none; font-size: 0.875rem;">
                  üìû ${this.phone}
                </a>
              </div>
            ` : ''}

            ${this.email ? `
              <div style="margin: 12px 0;">
                <strong style="color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em;">
                  E-post:
                </strong><br/>
                <a href="mailto:${this.email}" style="color: var(--color-primary); text-decoration: none; font-size: 0.875rem;">
                  ‚úâÔ∏è ${this.email}
                </a>
              </div>
            ` : ''}

            ${this.openingHours ? `
              <div style="margin: 12px 0;">
                <strong style="color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em;">
                  √ñppettider:
                </strong><br/>
                <span style="color: var(--text-primary); font-size: 0.875rem;">
                  ${Utils.sanitizeHTML(this.openingHours)}
                </span>
              </div>
            ` : ''}

            ${this.website ? `
              <div style="margin: 12px 0; padding-top: 8px; border-top: 1px solid var(--border-light);">
                <a href="${this.website}" target="_blank" style="color: var(--color-primary); text-decoration: none; font-size: 0.875rem; font-weight: 500;">
                  üåê Mer information ‚Üí
                </a>
              </div>
            ` : ''}
          </div>
        `;
      }
    }

    // ===== DATA STORAGE =====
    class DataStorage {
      static DB_NAME = 'PoliceEventsDB';
      static DB_VERSION = 2;
      static EVENTS_STORE = 'events';
      static STATIONS_STORE = 'stations';
      static FAVORITES_STORE = 'favorites';

      static db = null;

      static async initialize() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

          request.onerror = () => reject(request.error);
          request.onsuccess = () => {
            this.db = request.result;
            resolve();
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;

            // Events store
            if (!db.objectStoreNames.contains(this.EVENTS_STORE)) {
              const eventsStore = db.createObjectStore(this.EVENTS_STORE, { keyPath: 'id' });
              eventsStore.createIndex('timestamp', 'timeMs');
              eventsStore.createIndex('type', 'type');
              eventsStore.createIndex('city', 'city');
            }

            // Stations store
            if (!db.objectStoreNames.contains(this.STATIONS_STORE)) {
              const stationsStore = db.createObjectStore(this.STATIONS_STORE, { keyPath: 'id' });
            }

            // Favorites store
            if (!db.objectStoreNames.contains(this.FAVORITES_STORE)) {
              const favoritesStore = db.createObjectStore(this.FAVORITES_STORE, { keyPath: 'id' });
              favoritesStore.createIndex('type', 'type'); // 'event' or 'location'
              favoritesStore.createIndex('timestamp', 'savedAt');
            }
          };
        });
      }

      static async saveEvents(events) {
        if (!this.db) await this.initialize();

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.EVENTS_STORE], 'readwrite');
          const store = transaction.objectStore(this.EVENTS_STORE);

          transaction.onerror = () => reject(transaction.error);
          transaction.oncomplete = () => resolve();

          events.forEach(event => {
            const eventData = {
              id: event.id,
              timeMs: event.timeMs,
              timestamp: event.timestamp,
              type: event.type,
              title: event.title,
              description: event.description,
              city: event.city,
              address: event.address,
              lat: event.lat,
              lng: event.lng,
              exactLocation: event.exactLocation,
              severityInfo: event.severityInfo,
              url: event.url
            };
            store.put(eventData);
          });
        });
      }

      static async getRecentEvents(maxAge = 7 * 24 * 60 * 60 * 1000) { // 7 days
        if (!this.db) await this.initialize();

        const cutoff = Date.now() - maxAge;

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.EVENTS_STORE], 'readonly');
          const store = transaction.objectStore(this.EVENTS_STORE);
          const index = store.index('timestamp');

          const range = IDBKeyRange.lowerBound(cutoff);
          const request = index.getAll(range);

          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result || []);
        });
      }

      static async saveStations(stations) {
        if (!this.db) await this.initialize();

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.STATIONS_STORE], 'readwrite');
          const store = transaction.objectStore(this.STATIONS_STORE);

          transaction.onerror = () => reject(transaction.error);
          transaction.oncomplete = () => resolve();

          stations.forEach(station => {
            const stationData = {
              id: station.id,
              name: station.name,
              lat: station.lat,
              lng: station.lng,
              address: station.address,
              phone: station.phone,
              email: station.email,
              website: station.website,
              services: station.services,
              servicesText: station.servicesText,
              openingHours: station.openingHours
            };
            store.put(stationData);
          });
        });
      }

      static async getAllStations() {
        if (!this.db) await this.initialize();

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.STATIONS_STORE], 'readonly');
          const store = transaction.objectStore(this.STATIONS_STORE);
          const request = store.getAll();

          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result || []);
        });
      }

      // Favorites management
      static async saveFavorite(item) {
        if (!this.db) await this.initialize();

        const favoriteItem = {
          id: item.type === 'event' ? `event_${item.id}` : `location_${Date.now()}`,
          type: item.type, // 'event' or 'location'
          data: item,
          savedAt: new Date().toISOString()
        };

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.FAVORITES_STORE], 'readwrite');
          const store = transaction.objectStore(this.FAVORITES_STORE);

          const request = store.put(favoriteItem);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(favoriteItem);
        });
      }

      static async getFavorites(type = null) {
        if (!this.db) await this.initialize();

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.FAVORITES_STORE], 'readonly');
          const store = transaction.objectStore(this.FAVORITES_STORE);

          const request = type ? store.index('type').getAll(type) : store.getAll();
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result || []);
        });
      }

      static async removeFavorite(id) {
        if (!this.db) await this.initialize();

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.FAVORITES_STORE], 'readwrite');
          const store = transaction.objectStore(this.FAVORITES_STORE);

          const request = store.delete(id);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve();
        });
      }

      static async isFavorite(id, type) {
        const favoriteId = `${type}_${id}`;
        const favorites = await this.getFavorites(type);
        return favorites.some(fav => fav.id === favoriteId);
      }
    }

    // ===== MAIN APPLICATION =====
    class PoliceEventsApp {
      constructor() {
        this.state = {
          events: [],
          filteredEvents: [],
          stations: [],
          currentView: 'markers', // 'markers' | 'heatmap'
          maxEvents: 500,
          filters: {
            types: [],
            searchQuery: '',
            timelineHour: null,
            dateFrom: null,
            dateTo: null,
            locationCenter: null,
            locationRadius: 10,
            priorityFilter: null
          },
          map: null,
          layers: {
            eventCluster: null,
            stationCluster: null,
            heatLayer: null
          },
          ui: {
            loading: false,
            statsVisible: false,
            timelineVisible: false,
            favoritesVisible: false,
            favoritesActiveTab: 'events',
            timeline: {
              playing: false,
              currentHour: 0,
              timer: null
            }
          },
          favorites: {
            events: [],
            locations: []
          },
          userLocation: null,
          charts: {
            timeline: null,
            types: null
          }
        };

        this.initialize();
      }

      async initialize() {
        try {
          // Initialize storage
          await DataStorage.initialize();

          // Initialize map first
          this.initializeMap();

          // Bind event listeners
          this.bindEventListeners();

          // Load initial data and show immediately
          await this.loadInitialData();

          // Force immediate map update
          this.renderEvents();
          this.updateUI();

          Utils.showToast('Kartan har laddats framg√•ngsrikt', 3000, 'success');
        } catch (error) {
          console.error('Initialization error:', error);
          Utils.showToast('Fel vid initialisering av kartan', 5000, 'error');
        }
      }

      initializeMap() {
        // Create map centered on Sweden
        this.state.map = L.map('map', {
          center: [62.0, 15.0],
          zoom: 5,
          zoomControl: true,
          minZoom: 4,
          maxZoom: 18
        });

        // Add tile layer with proper attribution
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 18,
          attribution: '¬© <a href="https://openstreetmap.org">OpenStreetMap</a> contributors'
        }).addTo(this.state.map);

        // Initialize marker clusters
        this.initializeMarkerClusters();

        // Map event listeners
        this.state.map.on('zoomend', Utils.throttle(() => {
          this.updateMarkerSizes();
        }, 150));

        this.state.map.on('moveend', Utils.throttle(() => {
          this.updateVisibleStats();
        }, 300));
      }

      initializeMarkerClusters() {
        // Event cluster with reduced clustering for better individual visibility
        this.state.layers.eventCluster = L.markerClusterGroup({
          chunkedLoading: true,
          maxClusterRadius: 25, // Reduced clustering
          disableClusteringAtZoom: 11, // Show individual markers earlier
          spiderfyOnMaxZoom: true,
          showCoverageOnHover: false,
          zoomToBoundsOnClick: true,
          iconCreateFunction: (cluster) => {
            const count = cluster.getChildCount();
            const size = count < 10 ? 'small' : count < 100 ? 'medium' : 'large';

            return L.divIcon({
              html: `<div class="event-cluster-${size}" style="
                background: var(--color-primary);
                color: white;
                border: 2px solid white;
                border-radius: 50%;
                width: ${size === 'small' ? '30px' : size === 'medium' ? '40px' : '50px'};
                height: ${size === 'small' ? '30px' : size === 'medium' ? '40px' : '50px'};
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: ${size === 'small' ? '12px' : size === 'medium' ? '14px' : '16px'};
                font-weight: 600;
                box-shadow: var(--shadow-md);
              ">${count}</div>`,
              className: 'event-cluster-marker',
              iconSize: [size === 'small' ? 30 : size === 'medium' ? 40 : 50, size === 'small' ? 30 : size === 'medium' ? 40 : 50]
            });
          }
        });

        // Police station cluster
        this.state.layers.stationCluster = L.markerClusterGroup({
          chunkedLoading: true,
          maxClusterRadius: 40,
          disableClusteringAtZoom: 9, // Cluster at lower zoom levels
          spiderfyOnMaxZoom: false,
          showCoverageOnHover: false,
          zoomToBoundsOnClick: true,
          iconCreateFunction: (cluster) => {
            const count = cluster.getChildCount();

            return L.divIcon({
              html: `<div style="
                background: var(--color-secondary);
                color: white;
                border: 1px solid white;
                border-radius: 50%;
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 11px;
                font-weight: 500;
                box-shadow: var(--shadow-sm);
              ">${count}</div>`,
              className: 'station-cluster-marker',
              iconSize: [24, 24]
            });
          }
        });

        // Add station cluster to map (always visible)
        this.state.layers.stationCluster.addTo(this.state.map);
      }

      bindEventListeners() {
        // Control event listeners
        document.getElementById('max-events').addEventListener('change',
          Utils.debounce(() => this.updateMaxEvents(), 300));

        document.getElementById('event-type').addEventListener('change',
          () => this.updateTypeFilter());

        document.getElementById('search-query').addEventListener('input',
          Utils.debounce(() => this.updateSearchFilter(), 300));

        // View mode buttons
        document.getElementById('view-markers').addEventListener('click',
          () => this.setViewMode('markers'));

        document.getElementById('view-heatmap').addEventListener('click',
          () => this.setViewMode('heatmap'));

        // Function buttons
        document.getElementById('locate-user').addEventListener('click',
          () => this.locateUser());

        document.getElementById('timeline-toggle').addEventListener('click',
          () => this.toggleTimeline());

        document.getElementById('refresh-data').addEventListener('click',
          () => this.refreshData());

        // Floating action buttons
        document.getElementById('fullscreen-toggle').addEventListener('click',
          () => this.toggleFullscreen());

        document.getElementById('stats-toggle').addEventListener('click',
          () => this.toggleStats());

        // Panel controls
        document.getElementById('legend-close').addEventListener('click',
          () => this.hideLegend());

        document.getElementById('stats-close').addEventListener('click',
          () => this.hideStats());

        document.getElementById('favorites-toggle').addEventListener('click',
          () => this.toggleFavorites());

        document.getElementById('favorites-close').addEventListener('click',
          () => this.hideFavorites());

        document.getElementById('tab-events').addEventListener('click',
          () => this.setFavoritesTab('events'));

        document.getElementById('tab-locations').addEventListener('click',
          () => this.setFavoritesTab('locations'));

        // Timeline controls
        document.getElementById('timeline-play').addEventListener('click',
          () => this.playTimeline());

        document.getElementById('timeline-pause').addEventListener('click',
          () => this.pauseTimeline());

        document.getElementById('timeline-close').addEventListener('click',
          () => this.hideTimeline());

        document.getElementById('timeline-slider').addEventListener('input',
          (e) => this.updateTimelineHour(parseInt(e.target.value)));

        // RSS filter
        document.getElementById('rss-filter').addEventListener('input',
          Utils.debounce(() => this.filterRSSItems(), 200));

        // Advanced filters
        document.getElementById('date-from').addEventListener('change', () => this.updateDateFilter());
        document.getElementById('date-to').addEventListener('change', () => this.updateDateFilter());
        document.getElementById('location-search').addEventListener('input',
          Utils.debounce(() => this.updateLocationFilter(), 500));
        document.getElementById('distance-radius').addEventListener('change', () => this.updateLocationFilter());
        document.getElementById('use-current-location').addEventListener('click', () => this.useCurrentLocation());

        // Quick filters
        document.getElementById('filter-today').addEventListener('click', () => this.applyQuickFilter('today'));
        document.getElementById('filter-week').addEventListener('click', () => this.applyQuickFilter('week'));
        document.getElementById('filter-high-priority').addEventListener('click', () => this.applyQuickFilter('high-priority'));
        document.getElementById('filter-clear').addEventListener('click', () => this.clearAllFilters());

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => this.handleKeyboardShortcuts(e));
      }

      async loadInitialData() {
        Utils.showLoading('Laddar polisdata...');

        try {
          // Load both events and stations in parallel
          const [eventsData, stationsData] = await Promise.allSettled([
            this.loadPoliceEvents(),
            this.loadPoliceStations()
          ]);

          if (eventsData.status === 'rejected') {
            console.error('Failed to load events:', eventsData.reason);
            Utils.showToast('Kunde inte ladda polish√§ndelser', 4000, 'error');
          }

          if (stationsData.status === 'rejected') {
            console.error('Failed to load stations:', stationsData.reason);
            Utils.showToast('Kunde inte ladda polisstationer', 4000, 'warning');
          }

          // Load RSS feed (non-critical)
          this.loadRSSFeed().catch(error => {
            console.warn('RSS feed failed:', error);
          });

        } finally {
          Utils.hideLoading();
        }
      }

      async loadPoliceEvents() {
        try {
          // Try to load cached events first
          const cachedEvents = await DataStorage.getRecentEvents();

          if (cachedEvents.length > 0) {
            // Recreate event objects from cached data
            this.state.events = cachedEvents.map(data => {
              const event = Object.create(PoliceEvent.prototype);
              return Object.assign(event, data);
            });

            // Immediately show cached events on map
            this.applyFilters();
            this.updateEventTypeSelect();
            this.renderEvents(); // Force immediate rendering
            Utils.showToast(`Laddade ${this.state.events.length} cachade h√§ndelser`, 2000, 'success');
          }

          // Fetch fresh data from API
          const response = await Utils.fetchWithRetry('https://polisen.se/api/events');
          const rawEvents = await Utils.safeJsonParse(response);

          if (!Array.isArray(rawEvents)) {
            throw new Error('Ogiltig data fr√•n Polisen API');
          }

          // Parse events
          const events = rawEvents
            .map(raw => new PoliceEvent(raw))
            .filter(event => event.isValidEvent())
            .sort((a, b) => b.timeMs - a.timeMs)
            .slice(0, this.state.maxEvents);

          // Merge with cached events and deduplicate
          const eventMap = new Map();

          // Add cached events first
          cachedEvents.forEach(event => eventMap.set(event.id, event));

          // Add fresh events (will overwrite cached events with same ID)
          events.forEach(event => eventMap.set(event.id, event));

          // Convert back to array and sort
          this.state.events = Array.from(eventMap.values())
            .sort((a, b) => b.timeMs - a.timeMs)
            .slice(0, this.state.maxEvents);

          // Cache new events
          await DataStorage.saveEvents(events);

          // Update UI immediately
          this.applyFilters();
          this.updateEventTypeSelect();
          this.renderEvents(); // Force immediate rendering of new data

          Utils.showToast(`Uppdaterade med ${this.state.events.length} polish√§ndelser`, 2000, 'success');

        } catch (error) {
          console.error('Error loading police events:', error);
          throw error;
        }
      }

      async loadPoliceStations() {
        try {
          // Try cached stations first
          const cachedStations = await DataStorage.getAllStations();

          if (cachedStations.length > 0) {
            this.state.stations = cachedStations.map(data => {
              const station = Object.create(PoliceStation.prototype);
              return Object.assign(station, data);
            });

            this.renderStations();
            Utils.showToast(`Laddade ${this.state.stations.length} cachade polisstationer`, 2000, 'success');
          }

          // Fetch fresh data
          const response = await Utils.fetchWithRetry('https://polisen.se/api/policestations');
          const rawStations = await Utils.safeJsonParse(response);

          if (!Array.isArray(rawStations)) {
            throw new Error('Ogiltig data fr√•n Polisstationer API');
          }

          // Parse stations
          const stations = rawStations
            .map(raw => new PoliceStation(raw))
            .filter(station => station.isValidStation());

          this.state.stations = stations;

          // Cache stations
          await DataStorage.saveStations(stations);

          // Render stations
          this.renderStations();

          Utils.showToast(`Laddade ${stations.length} polisstationer`, 2000, 'success');

        } catch (error) {
          console.error('Error loading police stations:', error);
          throw error;
        }
      }

      async loadRSSFeed() {
        try {
          const rssSources = [
            'https://polisen.se/aktuellt/rss/',
            'https://api.allorigins.win/get?url=' + encodeURIComponent('https://polisen.se/aktuellt/rss/'),
            'https://polisen.se/aktuellt/handelser/rss/'
          ];

          let rssContent = '';

          for (const source of rssSources) {
            try {
              if (source.includes('allorigins')) {
                const response = await Utils.fetchWithRetry(source);
                const data = await Utils.safeJsonParse(response);
                rssContent = data.contents || '';
              } else {
                const response = await Utils.fetchWithRetry(source);
                rssContent = await response.text();
              }

              if (rssContent && rssContent.trim().length > 100) {
                break;
              }
            } catch (error) {
              console.warn(`RSS source ${source} failed:`, error);
            }
          }

          if (!rssContent || rssContent.trim().length < 100) {
            // Use fallback data for demonstration
            this.state.rssItems = [
              {
                title: 'Polisen informerar om trafiks√§kerhet',
                link: '#',
                pubDate: new Date().toISOString(),
                description: 'Viktiga s√§kerhets√•tg√§rder under vinterf√∂rh√•llanden',
                location: 'Nationellt'
              },
              {
                title: 'St√∂rre polisinsats i centrala Stockholm',
                link: '#',
                pubDate: new Date(Date.now() - 3600000).toISOString(),
                description: 'Polisen genomf√∂r kontroller i city',
                location: 'Stockholm'
              },
              {
                title: 'Varning f√∂r telefonbedr√§gerier',
                link: '#',
                pubDate: new Date(Date.now() - 7200000).toISOString(),
                description: '√ñkat antal anm√§lningar om falska poliser',
                location: 'Nationellt'
              }
            ];
          } else {
            this.parseRSSFeed(rssContent);
          }

          this.renderRSSItems();

        } catch (error) {
          console.warn('RSS feed error:', error);
          // Fallback data already set above
        }
      }

      parseRSSFeed(xmlContent) {
        try {
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
          const items = xmlDoc.querySelectorAll('item');

          this.state.rssItems = Array.from(items).slice(0, 30).map(item => {
            const title = item.querySelector('title')?.textContent || '';
            const link = item.querySelector('link')?.textContent || '#';
            const description = item.querySelector('description')?.textContent || '';
            const pubDate = item.querySelector('pubDate')?.textContent || '';

            // Extract location from title or description
            const locationMatch = (title + ' ' + description).match(
              /(?:i|fr√•n|vid)\s+([A-Z√Ö√Ñ√ñ][a-z√•√§√∂]+(?:\s+[A-Z√Ö√Ñ√ñ][a-z√•√§√∂]+)?)/
            );
            const location = locationMatch ? locationMatch[1] : 'Ok√§nd plats';

            return {
              title: Utils.sanitizeHTML(title),
              link,
              description: Utils.sanitizeHTML(description),
              pubDate,
              location: Utils.sanitizeHTML(location),
              formattedDate: this.formatRSSDate(pubDate)
            };
          });

        } catch (error) {
          console.error('RSS parsing error:', error);
          this.state.rssItems = [];
        }
      }

      formatRSSDate(dateString) {
        try {
          const date = new Date(dateString);
          return Utils.formatDate(date);
        } catch {
          return dateString;
        }
      }

      updateMaxEvents() {
        const input = document.getElementById('max-events');
        const value = Math.max(50, Math.min(1000, parseInt(input.value) || 500));

        input.value = value;
        this.state.maxEvents = value;

        // Re-slice events to new limit
        this.state.events = this.state.events.slice(0, value);
        this.applyFilters();
      }

      updateTypeFilter() {
        const select = document.getElementById('event-type');
        this.state.filters.types = Array.from(select.selectedOptions).map(option => option.value);
        this.applyFilters();
      }

      updateSearchFilter() {
        const input = document.getElementById('search-query');
        this.state.filters.searchQuery = input.value.toLowerCase().trim();
        this.applyFilters();
      }

      updateTimelineHour(hour) {
        this.state.filters.timelineHour = hour;
        this.state.ui.timeline.currentHour = hour;

        document.getElementById('timeline-time').textContent =
          `${String(hour).padStart(2, '0')}:00`;

        this.applyFilters();
      }

      applyFilters() {
        let filtered = [...this.state.events];

        // Type filter
        if (this.state.filters.types.length > 0) {
          filtered = filtered.filter(event =>
            this.state.filters.types.includes(event.type)
          );
        }

        // Search filter
        if (this.state.filters.searchQuery) {
          const query = this.state.filters.searchQuery;
          filtered = filtered.filter(event =>
            event.title.toLowerCase().includes(query) ||
            event.description.toLowerCase().includes(query) ||
            event.city.toLowerCase().includes(query) ||
            event.type.toLowerCase().includes(query)
          );
        }

        // Timeline hour filter
        if (this.state.filters.timelineHour !== null) {
          filtered = filtered.filter(event => {
            const eventHour = event.timestamp.getHours();
            return eventHour === this.state.filters.timelineHour;
          });
        }

        // Date range filter
        if (this.state.filters.dateFrom || this.state.filters.dateTo) {
          filtered = filtered.filter(event => {
            const eventDate = new Date(event.timestamp.toDateString());
            let include = true;

            if (this.state.filters.dateFrom) {
              include = include && eventDate >= this.state.filters.dateFrom;
            }

            if (this.state.filters.dateTo) {
              include = include && eventDate <= this.state.filters.dateTo;
            }

            return include;
          });
        }

        // Location proximity filter
        if (this.state.filters.locationCenter && this.state.filters.locationRadius) {
          const centerLat = this.state.filters.locationCenter.lat;
          const centerLng = this.state.filters.locationCenter.lng;
          const maxDistance = this.state.filters.locationRadius;

          filtered = filtered.filter(event => {
            if (!event.lat || !event.lng) return true; // Include events without coordinates
            const distance = this.calculateDistance(centerLat, centerLng, event.lat, event.lng);
            return distance <= maxDistance;
          });
        }

        // Priority filter
        if (this.state.filters.priorityFilter) {
          filtered = filtered.filter(event => {
            const severity = event.severityInfo || { priority: 'medium' };
            if (this.state.filters.priorityFilter === 'high-priority') {
              return severity.priority === 'high' || severity.priority === 'critical';
            }
            return true;
          });
        }

        this.state.filteredEvents = filtered;
        this.renderEvents();
        this.updateLegend();
        this.updateCharts();
      }

      setViewMode(mode) {
        this.state.currentView = mode;

        // Update button states
        document.getElementById('view-markers').classList.toggle('active', mode === 'markers');
        document.getElementById('view-heatmap').classList.toggle('active', mode === 'heatmap');

        this.renderEvents();
      }

      renderEvents() {
        // Clear existing event layers
        if (this.state.layers.eventCluster) {
          this.state.map.removeLayer(this.state.layers.eventCluster);
          this.state.layers.eventCluster.clearLayers();
        }

        if (this.state.layers.heatLayer) {
          this.state.map.removeLayer(this.state.layers.heatLayer);
          this.state.layers.heatLayer = null;
        }

        if (this.state.currentView === 'heatmap') {
          this.renderHeatmap();
        } else {
          this.renderMarkers();
        }
      }

      renderMarkers() {
        const zoom = this.state.map.getZoom();
        const baseRadius = Math.max(6, Math.min(14, zoom - 2));

        this.state.filteredEvents.forEach(event => {
          const severityColor = event.severityInfo.color;

          const marker = L.circleMarker([event.lat, event.lng], {
            radius: baseRadius + (event.exactLocation ? 2 : 0),
            color: '#ffffff',
            fillColor: severityColor,
            fillOpacity: event.exactLocation ? 0.9 : 0.75,
            weight: event.exactLocation ? 2 : 1.5,
            className: `crime-marker ${event.exactLocation ? 'exact-location' : 'approximate-location'}`,
            zIndexOffset: 1000 // Above police stations
          });

          marker.bindPopup(event.getPopupContent(), {
            maxWidth: 320,
            className: 'crime-event-popup'
          });

          this.state.layers.eventCluster.addLayer(marker);
        });

        this.state.layers.eventCluster.addTo(this.state.map);
      }

      renderHeatmap() {
        const heatPoints = this.state.filteredEvents.map(event => [
          event.lat,
          event.lng,
          Math.max(0.3, event.severityInfo.level / 5) // Intensity based on severity
        ]);

        const zoom = this.state.map.getZoom();
        const radius = Math.max(15, Math.min(50, zoom * 3));

        this.state.layers.heatLayer = L.heatLayer(heatPoints, {
          radius: radius,
          blur: 20,
          maxZoom: 15,
          minOpacity: 0.4,
          gradient: {
            0.0: '#22c55e',
            0.2: '#f59e0b',
            0.4: '#f97316',
            0.6: '#dc2626',
            0.8: '#991b1b',
            1.0: '#7f1d1d'
          }
        });

        this.state.layers.heatLayer.addTo(this.state.map);
      }

      renderStations() {
        // Clear existing station markers
        this.state.layers.stationCluster.clearLayers();

        this.state.stations.forEach(station => {
          const marker = station.createMarker();
          if (marker) {
            this.state.layers.stationCluster.addLayer(marker);
          }
        });
      }

      updateEventTypeSelect() {
        const select = document.getElementById('event-type');
        const currentValues = Array.from(select.selectedOptions).map(o => o.value);

        // Get unique types and sort them
        const types = [...new Set(this.state.events.map(event => event.type))].sort();

        // Clear and rebuild options
        select.innerHTML = '';

        types.forEach(type => {
          const option = document.createElement('option');
          option.value = type;
          option.textContent = type;
          option.selected = currentValues.includes(type);
          select.appendChild(option);
        });

        // Set reasonable size
        select.size = Math.min(6, Math.max(1, types.length));
      }

      updateLegend() {
        const statsEl = document.getElementById('legend-stats');
        const itemsEl = document.getElementById('legend-items');

        const total = this.state.filteredEvents.length;
        const exactCount = this.state.filteredEvents.filter(e => e.exactLocation).length;
        const approxCount = total - exactCount;

        statsEl.innerHTML = `
          <div style="margin-bottom: 8px;">
            <strong>${total}</strong> h√§ndelser visas
          </div>
          <div style="font-size: 0.7rem; color: var(--text-muted);">
            Exakt position: ${exactCount} | Ungef√§rlig: ${approxCount}
          </div>
        `;

        // Count by type
        const typeCounts = {};
        this.state.filteredEvents.forEach(event => {
          typeCounts[event.type] = (typeCounts[event.type] || 0) + 1;
        });

        // Get top 6 most common types
        const topTypes = Object.entries(typeCounts)
          .sort(([,a], [,b]) => b - a)
          .slice(0, 6);

        itemsEl.innerHTML = topTypes.map(([type, count]) => {
          const color = CrimeSeveritySystem.getSeverityColor(type);
          return `
            <div class="legend-item">
              <div class="legend-dot" style="background: ${color}"></div>
              <span>${type} (${count})</span>
            </div>
          `;
        }).join('');
      }

      updateMarkerSizes() {
        if (this.state.currentView === 'markers') {
          this.renderEvents(); // Re-render with new sizes
        }
      }

      updateVisibleStats() {
        // Update any statistics that depend on current map view
        this.updateLegend();
      }

      updateCharts() {
        if (this.state.ui.statsVisible) {
          this.renderTimelineChart();
          this.renderTypeChart();
        }
      }

      renderTimelineChart() {
        const canvas = document.getElementById('timeline-chart');
        const ctx = canvas.getContext('2d');

        // Destroy existing chart
        if (this.state.charts.timeline) {
          this.state.charts.timeline.destroy();
        }

        // Group events by hour
        const hourCounts = new Array(24).fill(0);
        this.state.filteredEvents.forEach(event => {
          const hour = event.timestamp.getHours();
          hourCounts[hour]++;
        });

        this.state.charts.timeline = new Chart(ctx, {
          type: 'line',
          data: {
            labels: Array.from({length: 24}, (_, i) => `${String(i).padStart(2, '0')}:00`),
            datasets: [{
              label: 'Antal h√§ndelser',
              data: hourCounts,
              borderColor: 'var(--color-primary)',
              backgroundColor: 'rgba(30, 64, 175, 0.1)',
              borderWidth: 2,
              fill: true,
              tension: 0.4
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  precision: 0
                }
              }
            }
          }
        });
      }

      renderTypeChart() {
        const canvas = document.getElementById('type-chart');
        const ctx = canvas.getContext('2d');

        // Destroy existing chart
        if (this.state.charts.types) {
          this.state.charts.types.destroy();
        }

        // Count by type
        const typeCounts = {};
        this.state.filteredEvents.forEach(event => {
          typeCounts[event.type] = (typeCounts[event.type] || 0) + 1;
        });

        const sortedTypes = Object.entries(typeCounts)
          .sort(([,a], [,b]) => b - a)
          .slice(0, 8); // Top 8 types

        const labels = sortedTypes.map(([type]) => type);
        const data = sortedTypes.map(([,count]) => count);
        const colors = labels.map(type => CrimeSeveritySystem.getSeverityColor(type));

        this.state.charts.types = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: labels,
            datasets: [{
              data: data,
              backgroundColor: colors,
              borderWidth: 2,
              borderColor: '#ffffff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  boxWidth: 12,
                  padding: 10,
                  font: {
                    size: 11
                  }
                }
              }
            }
          }
        });
      }

      renderRSSItems() {
        const container = document.getElementById('rss-items');
        const filter = document.getElementById('rss-filter').value.toLowerCase();

        const filteredItems = (this.state.rssItems || []).filter(item => {
          if (!filter) return true;
          return item.title.toLowerCase().includes(filter) ||
                 item.description.toLowerCase().includes(filter) ||
                 item.location.toLowerCase().includes(filter);
        });

        container.innerHTML = filteredItems.map(item => `
          <div style="border-bottom: 1px solid var(--border-light); padding: 12px 0;">
            <h5 style="margin: 0 0 6px; font-size: 0.875rem;">
              <a href="${item.link}" target="_blank" style="color: var(--color-primary); text-decoration: none;">
                ${item.title}
              </a>
            </h5>
            <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">
              üìç ${item.location} ‚Ä¢ üïí ${item.formattedDate}
            </div>
            <div style="font-size: 0.8rem; color: var(--text-secondary);">
              ${item.description}
            </div>
          </div>
        `).join('');

        if (filteredItems.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-muted);">Inga nyheter matchar s√∂kningen</div>';
        }
      }

      filterRSSItems() {
        this.renderRSSItems();
      }

      async locateUser() {
        if (!navigator.geolocation) {
          Utils.showToast('Geolokalisering st√∂ds inte i denna webbl√§sare', 4000, 'error');
          return;
        }

        Utils.showLoading('Lokaliserar din position...');

        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(
              resolve,
              reject,
              {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 300000 // 5 minutes
              }
            );
          });

          const { latitude, longitude } = position.coords;
          this.state.userLocation = [latitude, longitude];

          // Add user location marker
          if (this.state.userLocationMarker) {
            this.state.map.removeLayer(this.state.userLocationMarker);
          }

          this.state.userLocationMarker = L.marker([latitude, longitude], {
            icon: L.divIcon({
              className: 'user-location-marker',
              html: '<div style="background: var(--color-primary); color: white; border: 3px solid white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; box-shadow: var(--shadow-md);">üìç</div>',
              iconSize: [20, 20],
              iconAnchor: [10, 10]
            })
          });

          this.state.userLocationMarker.addTo(this.state.map);
          this.state.map.setView([latitude, longitude], 12);

          Utils.showToast('Position hittad! Kartan centrerad p√• din plats', 3000, 'success');

        } catch (error) {
          console.error('Geolocation error:', error);
          Utils.showToast('Kunde inte h√§mta din position. Kontrollera beh√∂righeter', 4000, 'error');
        } finally {
          Utils.hideLoading();
        }
      }

      toggleTimeline() {
        this.state.ui.timelineVisible = !this.state.ui.timelineVisible;
        const panel = document.getElementById('timeline-panel');
        panel.style.display = this.state.ui.timelineVisible ? 'block' : 'none';

        if (this.state.ui.timelineVisible) {
          // Reset timeline state
          this.state.filters.timelineHour = null;
          this.state.ui.timeline.currentHour = 0;
          document.getElementById('timeline-slider').value = 0;
          document.getElementById('timeline-time').textContent = '00:00';
          this.applyFilters();
        } else {
          this.hideTimeline();
        }
      }

      hideTimeline() {
        this.state.ui.timelineVisible = false;
        this.state.filters.timelineHour = null;

        if (this.state.ui.timeline.playing) {
          this.pauseTimeline();
        }

        document.getElementById('timeline-panel').style.display = 'none';
        this.applyFilters();
      }

      playTimeline() {
        if (this.state.ui.timeline.playing) return;

        this.state.ui.timeline.playing = true;

        this.state.ui.timeline.timer = setInterval(() => {
          this.state.ui.timeline.currentHour = (this.state.ui.timeline.currentHour + 1) % 24;

          document.getElementById('timeline-slider').value = this.state.ui.timeline.currentHour;
          this.updateTimelineHour(this.state.ui.timeline.currentHour);

          if (this.state.ui.timeline.currentHour === 23) {
            // Auto-pause at end of day
            setTimeout(() => this.pauseTimeline(), 1000);
          }
        }, 1500); // 1.5 seconds per hour

        document.getElementById('timeline-play').textContent = 'Spelar...';
      }

      pauseTimeline() {
        if (this.state.ui.timeline.timer) {
          clearInterval(this.state.ui.timeline.timer);
          this.state.ui.timeline.timer = null;
        }

        this.state.ui.timeline.playing = false;
        document.getElementById('timeline-play').textContent = 'Spela';
      }

      toggleFavorites() {
        const panel = document.getElementById('favorites-panel');
        if (!panel) return;

        this.state.ui.favoritesVisible = !this.state.ui.favoritesVisible;
        panel.style.display = this.state.ui.favoritesVisible ? 'flex' : 'none';

        if (this.state.ui.favoritesVisible) {
          this.setFavoritesTab(this.state.ui.favoritesActiveTab);
        }
      }

      hideFavorites() {
        const panel = document.getElementById('favorites-panel');
        if (!panel) return;

        this.state.ui.favoritesVisible = false;
        panel.style.display = 'none';
      }

      setFavoritesTab(tab) {
        if (!['events', 'locations'].includes(tab)) {
          return;
        }

        this.state.ui.favoritesActiveTab = tab;

        const eventsTab = document.getElementById('tab-events');
        const locationsTab = document.getElementById('tab-locations');
        const eventsContent = document.getElementById('favorites-events-content');
        const locationsContent = document.getElementById('favorites-locations-content');

        if (eventsTab) {
          eventsTab.classList.toggle('active', tab === 'events');
        }

        if (locationsTab) {
          locationsTab.classList.toggle('active', tab === 'locations');
        }

        if (eventsContent) {
          eventsContent.style.display = tab === 'events' ? 'block' : 'none';
        }

        if (locationsContent) {
          locationsContent.style.display = tab === 'locations' ? 'block' : 'none';
        }
      }

      async refreshData() {
        Utils.showLoading('Uppdaterar data...');

        try {
          await this.loadPoliceEvents();
          await this.loadPoliceStations();
          await this.loadRSSFeed();

          Utils.showToast('Data har uppdaterats framg√•ngsrikt', 3000, 'success');

        } catch (error) {
          console.error('Refresh error:', error);
          Utils.showToast('Ett fel uppstod vid uppdatering av data', 4000, 'error');
        } finally {
          Utils.hideLoading();
        }
      }

      toggleFullscreen() {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().then(() => {
            Utils.showToast('Fullsk√§rmsl√§ge aktiverat', 2000, 'success');
          }).catch(() => {
            Utils.showToast('Kunde inte aktivera fullsk√§rm', 3000, 'error');
          });
        } else {
          document.exitFullscreen().then(() => {
            Utils.showToast('Fullsk√§rmsl√§ge avaktiverat', 2000, 'info');
          });
        }
      }

      toggleStats() {
        this.state.ui.statsVisible = !this.state.ui.statsVisible;
        const panel = document.getElementById('stats-panel');
        panel.style.display = this.state.ui.statsVisible ? 'block' : 'none';

        if (this.state.ui.statsVisible) {
          // Render charts when panel is shown
          setTimeout(() => {
            this.renderTimelineChart();
            this.renderTypeChart();
            this.renderRSSItems();
          }, 100);
        }
      }

      hideStats() {
        this.state.ui.statsVisible = false;
        document.getElementById('stats-panel').style.display = 'none';
      }

      hideLegend() {
        document.getElementById('legend').style.display = 'none';
      }

      handleKeyboardShortcuts(event) {
        // Only handle shortcuts if no input is focused
        if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT') {
          return;
        }

        switch (event.key) {
          case 'r':
          case 'R':
            event.preventDefault();
            this.refreshData();
            break;

          case 'f':
          case 'F':
            event.preventDefault();
            this.toggleFullscreen();
            break;

          case 's':
          case 'S':
            event.preventDefault();
            this.toggleStats();
            break;

          case 't':
          case 'T':
            event.preventDefault();
            this.toggleTimeline();
            break;

          case 'l':
          case 'L':
            event.preventDefault();
            this.locateUser();
            break;

          case 'm':
          case 'M':
            event.preventDefault();
            this.setViewMode(this.state.currentView === 'markers' ? 'heatmap' : 'markers');
            break;

          case 'Escape':
            event.preventDefault();
            if (this.state.ui.statsVisible) this.hideStats();
            if (this.state.ui.timelineVisible) this.hideTimeline();
            break;
        }
      }

      updateUI() {
        // Update any UI elements that need initial setup
        this.updateLegend();

        // Set up service worker for offline functionality
        this.registerServiceWorker();

        // Add keyboard shortcut info to tooltips
        this.updateTooltips();
      }

      updateTooltips() {
        const shortcuts = {
          'refresh-data': 'Uppdatera (R)',
          'fullscreen-toggle': 'Fullsk√§rm (F)',
          'stats-toggle': 'Statistik (S)',
          'timeline-toggle': 'Tidslinje (T)',
          'locate-user': 'Min position (L)',
          'view-markers': 'Mark√∂rer (M)',
          'view-heatmap': 'V√§rmekarta (M)'
        };

        Object.entries(shortcuts).forEach(([id, tooltip]) => {
          const element = document.getElementById(id);
          if (element) {
            element.title = tooltip;
          }
        });
      }

      async registerServiceWorker() {
        if ('serviceWorker' in navigator) {
          try {
            await navigator.serviceWorker.register('/police-sw.js');
            console.log('Service Worker registered successfully');
          } catch (error) {
            console.warn('Service Worker registration failed:', error);
          }
        }
      }

      // Advanced filter methods
      updateDateFilter() {
        const dateFrom = document.getElementById('date-from').value;
        const dateTo = document.getElementById('date-to').value;

        this.state.filters.dateFrom = dateFrom ? new Date(dateFrom) : null;
        this.state.filters.dateTo = dateTo ? new Date(dateTo) : null;

        this.applyFilters();
      }

      updateLocationFilter() {
        const locationQuery = document.getElementById('location-search').value.trim();
        this.state.filters.locationRadius = parseInt(document.getElementById('distance-radius').value);

        if (locationQuery) {
          this.geocodeLocation(locationQuery);
        } else {
          this.state.filters.locationCenter = null;
          this.applyFilters();
        }
      }

      async geocodeLocation(query) {
        try {
          Utils.showToast('S√∂ker efter plats...', 1500, 'info');

          // Simple geocoding using Nominatim (OpenStreetMap)
          const response = await fetch(
            `https://nominatim.openstreetmap.org/search?format=json&country=sweden&q=${encodeURIComponent(query)}&limit=1`
          );
          const results = await response.json();

          if (results.length > 0) {
            this.state.filters.locationCenter = {
              lat: parseFloat(results[0].lat),
              lng: parseFloat(results[0].lon)
            };
            Utils.showToast(`Filtrerar inom ${this.state.filters.locationRadius} km fr√•n ${results[0].display_name.split(',')[0]}`, 3000, 'success');
            this.applyFilters();
          } else {
            Utils.showToast('Kunde inte hitta platsen', 3000, 'warning');
          }
        } catch (error) {
          console.error('Geocoding failed:', error);
          Utils.showToast('Fel vid platss√∂kning', 3000, 'error');
        }
      }

      useCurrentLocation() {
        if (!navigator.geolocation) {
          Utils.showToast('Geolokalisering st√∂ds inte', 3000, 'error');
          return;
        }

        Utils.showToast('H√§mtar din position...', 2000, 'info');

        navigator.geolocation.getCurrentPosition(
          (position) => {
            this.state.filters.locationCenter = {
              lat: position.coords.latitude,
              lng: position.coords.longitude
            };

            document.getElementById('location-search').value = `${position.coords.latitude.toFixed(4)}, ${position.coords.longitude.toFixed(4)}`;
            Utils.showToast(`Filtrerar inom ${this.state.filters.locationRadius} km fr√•n din position`, 3000, 'success');
            this.applyFilters();
          },
          (error) => {
            console.error('Geolocation error:', error);
            Utils.showToast('Kunde inte h√§mta din position', 3000, 'error');
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 300000
          }
        );
      }

      applyQuickFilter(type) {
        const now = new Date();

        switch (type) {
          case 'today':
            this.state.filters.dateFrom = new Date(now.toDateString());
            this.state.filters.dateTo = new Date(now.toDateString());
            document.getElementById('date-from').value = now.toISOString().split('T')[0];
            document.getElementById('date-to').value = now.toISOString().split('T')[0];
            Utils.showToast('Visar h√§ndelser fr√•n idag', 2000, 'success');
            break;

          case 'week':
            const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            this.state.filters.dateFrom = weekAgo;
            this.state.filters.dateTo = now;
            document.getElementById('date-from').value = weekAgo.toISOString().split('T')[0];
            document.getElementById('date-to').value = now.toISOString().split('T')[0];
            Utils.showToast('Visar h√§ndelser fr√•n senaste veckan', 2000, 'success');
            break;

          case 'high-priority':
            this.state.filters.priorityFilter = 'high-priority';
            Utils.showToast('Visar endast h√∂gprioriterade h√§ndelser', 2000, 'success');
            break;
        }

        // Update active button states
        document.querySelectorAll('#filter-today, #filter-week, #filter-high-priority').forEach(btn => {
          btn.classList.remove('active');
        });
        document.getElementById(`filter-${type}`).classList.add('active');

        this.applyFilters();
      }

      clearAllFilters() {
        // Reset all filters
        this.state.filters = {
          types: [],
          searchQuery: '',
          timelineHour: null,
          dateFrom: null,
          dateTo: null,
          locationCenter: null,
          locationRadius: 10,
          priorityFilter: null
        };

        // Reset form values
        document.getElementById('search-query').value = '';
        document.getElementById('date-from').value = '';
        document.getElementById('date-to').value = '';
        document.getElementById('location-search').value = '';
        document.getElementById('distance-radius').value = '10';
        document.getElementById('event-type').selectedIndex = -1;

        // Reset button states
        document.querySelectorAll('.btn-secondary.active').forEach(btn => {
          btn.classList.remove('active');
        });

        Utils.showToast('Alla filter rensade', 2000, 'success');
        this.applyFilters();
      }

      calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Earth's radius in kilometers
        const dLat = this.deg2rad(lat2 - lat1);
        const dLon = this.deg2rad(lon2 - lon1);
        const a =
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(this.deg2rad(lat1)) * Math.cos(this.deg2rad(lat2)) *
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      }

      deg2rad(deg) {
        return deg * (Math.PI/180);
      }
    }

    // ===== APPLICATION INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize the application
      window.policeEventsApp = new PoliceEventsApp();

      // Global error handler
      window.addEventListener('error', (event) => {
        console.error('Global error:', event.error);
        Utils.showToast('Ett ov√§ntat fel uppstod', 4000, 'error');
      });

      // Handle unhandled promise rejections
      window.addEventListener('unhandledrejection', (event) => {
        console.error('Unhandled promise rejection:', event.reason);
        Utils.showToast('Ett fel uppstod vid datahantering', 4000, 'error');
      });
    });

  </script>
</body>
</html>
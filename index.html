<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Interaktiv karta över polishändelser i Sverige - Realtidsdata från Polisen" />
  <title>Polishändelser Sverige - Interaktiv Realtidskarta</title>

  <!-- External Dependencies -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />

  <style>
    /* Modern CSS Variables - Premium Dark/Light Theme */
    :root {
      /* Primary Brand Colors - Deep Blues */
      --color-primary: #1e40af;
      --color-primary-light: #3b82f6;
      --color-primary-dark: #1e3a8a;
      --color-primary-gradient: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);

      /* Secondary Colors - Sophisticated Grays */
      --color-secondary: #374151;
      --color-secondary-light: #6b7280;
      --color-accent: #8b5cf6;
      --color-accent-light: #a78bfa;

      /* Semantic Colors */
      --color-warning: #f59e0b;
      --color-error: #ef4444;
      --color-success: #10b981;

      /* Premium Background System */
      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-tertiary: #f1f5f9;
      --bg-dark: #0f172a;
      --bg-dark-secondary: #1e293b;

      /* Glassmorphism & Modern Effects */
      --bg-glass: rgba(255, 255, 255, 0.7);
      --bg-glass-dark: rgba(15, 23, 42, 0.7);
      --bg-overlay: rgba(255, 255, 255, 0.9);
      --bg-overlay-dark: rgba(15, 23, 42, 0.9);
      --bg-blur: blur(20px);

      /* Gradient System */
      --gradient-primary: linear-gradient(135deg, #1e40af 0%, #3b82f6 50%, #8b5cf6 100%);
      --gradient-secondary: linear-gradient(135deg, #374151 0%, #6b7280 100%);
      --gradient-accent: linear-gradient(135deg, #8b5cf6 0%, #a78bfa 100%);
      --gradient-bg: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);

      /* Typography */
      --text-primary: #0f172a;
      --text-secondary: #475569;
      --text-muted: #64748b;
      --text-inverse: #ffffff;

      /* Enhanced Border System */
      --border-light: rgba(226, 232, 240, 0.8);
      --border-medium: rgba(203, 213, 225, 0.8);
      --border-dark: rgba(148, 163, 184, 0.8);
      --border-accent: rgba(139, 92, 246, 0.3);

      /* Premium Shadow System */
      --shadow-sm: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      --shadow-glow: 0 0 20px rgba(59, 130, 246, 0.3);
      --shadow-accent: 0 10px 15px -3px rgba(139, 92, 246, 0.2);

      /* Enhanced Radius System */
      --radius-sm: 6px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-xl: 20px;
      --radius-2xl: 24px;
      --radius-full: 9999px;

      /* Spacing remains the same */
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;
      --spacing-2xl: 48px;

      /* Enhanced Transition System */
      --transition-fast: 0.15s cubic-bezier(0.4, 0.0, 0.2, 1);
      --transition-normal: 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
      --transition-slow: 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
      --transition-bounce: 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    /* Reset & Base Styles */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      background: var(--gradient-bg);
      color: var(--text-primary);
      font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow-x: hidden;
    }

    /* Animated Background */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--gradient-bg);
      z-index: -2;
    }

    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 120%;
      height: 120%;
      background:
        radial-gradient(circle at 20% 80%, rgba(59, 130, 246, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(16, 185, 129, 0.05) 0%, transparent 50%);
      animation: float 20s ease-in-out infinite;
      z-index: -1;
    }

    @keyframes float {
      0%, 100% { transform: translate(0px, 0px) rotate(0deg); }
      33% { transform: translate(-20px, -30px) rotate(1deg); }
      66% { transform: translate(20px, 30px) rotate(-1deg); }
    }

    /* Layout */
    #app {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100vh;
      position: relative;
    }

    /* Header with Glassmorphism */
    header {
      background: var(--bg-glass);
      backdrop-filter: var(--bg-blur);
      border-bottom: 1px solid var(--border-light);
      box-shadow: var(--shadow-lg);
      padding: var(--spacing-md) var(--spacing-lg);
      position: sticky;
      top: 0;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }

    .header-content {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--spacing-md);
    }

    h1 {
      font-size: 1.75rem;
      font-weight: 800;
      color: var(--text-primary);
      margin: 0;
      background: var(--gradient-primary);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-size: 200% 100%;
      animation: shimmerText 3s ease-in-out infinite;
      letter-spacing: -0.02em;
      line-height: 1.2;
    }

    @keyframes shimmerText {
      0%, 100% { background-position: 200% center; }
      50% { background-position: 0% center; }
    }

    .header-subtitle {
      font-size: 0.95rem;
      color: var(--text-secondary);
      margin: var(--spacing-xs) 0 var(--spacing-lg);
      font-weight: 500;
      line-height: 1.4;
      letter-spacing: 0.01em;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      font-size: 0.75rem;
      color: var(--color-success);
      font-weight: 500;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      background: var(--color-success);
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Controls Grid */
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--spacing-md);
      align-items: start;
    }

    .control-group {
      background: var(--bg-glass);
      backdrop-filter: var(--bg-blur);
      border: 1px solid var(--border-glass);
      border-radius: var(--border-radius-xl);
      padding: var(--spacing-lg);
      box-shadow: var(--shadow-glass), var(--shadow-md);
      transition: all var(--transition-smooth);
      position: relative;
      overflow: hidden;
    }

    .control-group::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--gradient-primary);
      opacity: 0.4;
    }

    .control-group:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-glass), var(--shadow-xl);
      border-color: var(--color-primary-light);
      background: var(--bg-glass-hover);
    }

    .control-label {
      display: block;
      font-size: 0.8rem;
      font-weight: 700;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: var(--spacing-sm);
      transition: all var(--transition-smooth);
      position: relative;
    }

    .control-label::after {
      content: '';
      position: absolute;
      bottom: -4px;
      left: 0;
      width: 0;
      height: 2px;
      background: var(--gradient-primary);
      transition: width var(--transition-smooth);
    }

    .control-group:hover .control-label::after {
      width: 30px;
    }

    /* Form Elements */
    input, select, button {
      font-family: inherit;
      font-size: 0.875rem;
    }

    input[type="text"],
    input[type="number"],
    input[type="date"],
    select {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid var(--border-glass);
      border-radius: var(--border-radius-lg);
      background: var(--bg-glass);
      backdrop-filter: var(--bg-blur);
      color: var(--text-primary);
      transition: all var(--transition-smooth);
      outline: none;
      font-size: 0.9rem;
      font-weight: 500;
      box-shadow: var(--shadow-glass), var(--shadow-sm);
    }

    input[type="text"]::placeholder,
    input[type="number"]::placeholder {
      color: var(--text-muted);
      font-weight: 400;
    }

    input:focus,
    select:focus {
      border-color: var(--color-primary-light);
      box-shadow: var(--shadow-glass), 0 0 0 3px rgba(59, 130, 246, 0.15), var(--shadow-lg);
      background: var(--bg-glass-hover);
      transform: translateY(-1px);
    }

    select {
      cursor: pointer;
    }

    select:hover {
      border-color: var(--color-primary-light);
      transform: translateY(-1px);
    }

    /* Buttons */
    .button-group {
      display: flex;
      gap: var(--spacing-sm);
      flex-wrap: wrap;
    }

    button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-xs);
      padding: 12px 20px;
      border: 1px solid var(--border-glass);
      border-radius: var(--border-radius-lg);
      font-weight: 600;
      text-decoration: none;
      cursor: pointer;
      transition: all var(--transition-smooth);
      position: relative;
      overflow: hidden;
      white-space: nowrap;
      backdrop-filter: var(--bg-blur);
      font-size: 0.875rem;
      letter-spacing: 0.025em;
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left var(--transition-smooth);
    }

    button:hover::before {
      left: 100%;
    }

    .btn-primary {
      background: var(--gradient-primary);
      color: var(--text-inverse);
      border-color: var(--color-primary-light);
      box-shadow: var(--shadow-glass), var(--shadow-md);
    }

    .btn-primary:hover {
      background: var(--gradient-primary-hover);
      transform: translateY(-2px) scale(1.02);
      box-shadow: var(--shadow-glass), var(--shadow-xl);
      border-color: var(--color-primary);
    }

    .btn-secondary {
      background: var(--bg-glass);
      color: var(--text-primary);
      border-color: var(--border-glass);
      box-shadow: var(--shadow-glass), var(--shadow-sm);
    }

    .btn-secondary:hover {
      background: var(--bg-glass-hover);
      color: var(--color-primary);
      border-color: var(--color-primary-light);
      transform: translateY(-1px);
      box-shadow: var(--shadow-glass), var(--shadow-lg);
    }

    .btn-secondary.active {
      background: var(--gradient-primary);
      color: var(--text-inverse);
      border-color: var(--color-primary);
      box-shadow: var(--shadow-glass), var(--shadow-lg);
      transform: translateY(-1px);
    }

    /* Map Container */
    #map {
      width: 100%;
      height: 100%;
      position: relative;
      z-index: 1;
    }

    /* Floating UI Elements */
    .floating-panel {
      position: absolute;
      background: var(--bg-glass);
      backdrop-filter: var(--bg-blur);
      border: 1px solid var(--border-glass);
      border-radius: var(--border-radius-xl);
      box-shadow: var(--shadow-glass), var(--shadow-xl);
      z-index: 500;
      transition: all var(--transition-smooth);
      position: relative;
      overflow: hidden;
    }

    .floating-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--gradient-primary);
      opacity: 0.6;
    }

    .floating-panel:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-glass), var(--shadow-2xl);
      border-color: var(--color-primary-light);
    }

    /* Legend */
    .legend {
      bottom: var(--spacing-lg);
      right: var(--spacing-lg);
      padding: var(--spacing-md);
      min-width: 200px;
      max-width: 280px;
    }

    .legend-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0 0 var(--spacing-sm);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .legend-stats {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: var(--spacing-md);
      padding-bottom: var(--spacing-sm);
      border-bottom: 1px solid var(--border-light);
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-xs);
      font-size: 0.75rem;
    }

    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    /* Toast Notifications */
    .toast {
      position: fixed;
      top: var(--spacing-lg);
      right: var(--spacing-lg);
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
      box-shadow: var(--shadow-xl);
      z-index: 2000;
      display: none;
      max-width: 400px;
      font-size: 0.875rem;
      animation: slideIn 0.3s ease-out;
    }

    .toast.success {
      border-left: 4px solid var(--color-success);
    }

    .toast.error {
      border-left: 4px solid var(--color-error);
    }

    .toast.warning {
      border-left: 4px solid var(--color-warning);
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    /* Loading Indicator */
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-overlay);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-lg);
      padding: var(--spacing-xl);
      box-shadow: var(--shadow-xl);
      z-index: 1500;
      display: none;
      text-align: center;
    }

    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border-light);
      border-top: 3px solid var(--color-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto var(--spacing-md);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Enhanced Loading States */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(5px);
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .loading-content {
      text-align: center;
      background: var(--bg-primary);
      padding: var(--spacing-xl);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-xl);
      border: 1px solid var(--border-light);
      max-width: 300px;
      width: 90%;
    }

    .loading-spinner-modern {
      width: 40px;
      height: 40px;
      margin: 0 auto var(--spacing-md);
      position: relative;
    }

    .loading-spinner-modern::before,
    .loading-spinner-modern::after {
      content: '';
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 3px solid transparent;
    }

    .loading-spinner-modern::before {
      border-top-color: var(--color-primary);
      animation: spin 1s linear infinite;
    }

    .loading-spinner-modern::after {
      border-bottom-color: var(--color-primary-light);
      animation: spin 1s linear infinite reverse;
      opacity: 0.5;
    }

    .loading-text {
      font-size: 0.875rem;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .loading-progress {
      width: 100%;
      height: 4px;
      background: var(--bg-tertiary);
      border-radius: 2px;
      margin-top: var(--spacing-md);
      overflow: hidden;
    }

    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--color-primary), var(--color-primary-light));
      border-radius: 2px;
      width: 0%;
      transition: width 0.3s ease;
    }

    /* Skeleton Screens */
    .skeleton-container {
      padding: var(--spacing-md);
    }

    .skeleton {
      background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s infinite;
      border-radius: var(--radius-sm);
    }

    @keyframes skeleton-loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .skeleton-header {
      height: 24px;
      width: 60%;
      margin-bottom: var(--spacing-sm);
    }

    .skeleton-text {
      height: 16px;
      width: 100%;
      margin-bottom: var(--spacing-xs);
    }

    .skeleton-text:last-child {
      width: 75%;
    }

    .skeleton-card {
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
      margin-bottom: var(--spacing-sm);
    }

    .skeleton-circle {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: inline-block;
      margin-right: var(--spacing-sm);
    }

    .skeleton-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-lg);
    }

    .skeleton-stat {
      text-align: center;
    }

    .skeleton-stat-value {
      height: 32px;
      width: 80%;
      margin: 0 auto var(--spacing-xs);
    }

    .skeleton-stat-label {
      height: 16px;
      width: 100%;
    }

    /* Favorites and Bookmarks System */
    .favorites-panel {
      position: fixed;
      top: 100px;
      left: var(--spacing-lg);
      bottom: 100px;
      width: 320px;
      background: var(--bg-overlay);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      z-index: 500;
      display: none;
      flex-direction: column;
      overflow: hidden;
    }

    .favorites-header {
      padding: var(--spacing-md);
      border-bottom: 1px solid var(--border-light);
      background: var(--bg-primary);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .favorites-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
    }

    .favorites-content {
      flex: 1;
      overflow-y: auto;
      padding: var(--spacing-sm);
    }

    .favorites-tabs {
      display: flex;
      margin-bottom: var(--spacing-md);
      background: var(--bg-tertiary);
      border-radius: var(--radius-sm);
      padding: 2px;
    }

    .favorites-tab {
      flex: 1;
      padding: var(--spacing-xs) var(--spacing-sm);
      border: none;
      background: transparent;
      color: var(--text-secondary);
      font-size: 0.8rem;
      font-weight: 500;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .favorites-tab.active {
      background: var(--bg-primary);
      color: var(--text-primary);
      box-shadow: var(--shadow-sm);
    }

    .favorite-item {
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: var(--spacing-sm);
      margin-bottom: var(--spacing-xs);
      cursor: pointer;
      transition: all var(--transition-fast);
      position: relative;
    }

    .favorite-item:hover {
      box-shadow: var(--shadow-md);
      transform: translateY(-1px);
    }

    .favorite-item-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--spacing-xs);
    }

    .favorite-item-type {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .favorite-item-date {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .favorite-item-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
      line-height: 1.3;
    }

    .favorite-item-location {
      font-size: 0.75rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .favorite-item-actions {
      position: absolute;
      top: var(--spacing-xs);
      right: var(--spacing-xs);
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity var(--transition-fast);
    }

    .favorite-item:hover .favorite-item-actions {
      opacity: 1;
    }

    .favorite-action-btn {
      width: 20px;
      height: 20px;
      border: none;
      background: rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      transition: all var(--transition-fast);
    }

    .favorite-action-btn:hover {
      background: var(--color-error);
      color: white;
    }

    .favorite-star-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid var(--border-light);
      border-radius: 50%;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all var(--transition-fast);
      z-index: 10;
    }

    .favorite-star-btn:hover {
      background: var(--color-warning);
      color: white;
      transform: scale(1.1);
    }

    .favorite-star-btn.favorited {
      background: var(--color-warning);
      color: white;
    }

    .favorites-empty {
      text-align: center;
      padding: var(--spacing-xl);
      color: var(--text-muted);
    }

    .favorites-empty-icon {
      font-size: 3rem;
      margin-bottom: var(--spacing-md);
      opacity: 0.5;
    }

    /* Mobile adjustments for favorites */
    @media (max-width: 768px) {
      .favorites-panel {
        left: var(--spacing-sm);
        right: var(--spacing-sm);
        width: auto;
      }
    }

    /* Statistics Panel */
    .stats-panel {
      top: 100px;
      right: var(--spacing-lg);
      bottom: 100px;
      width: 350px;
      padding: var(--spacing-md);
      display: none;
      overflow-y: auto;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--spacing-md);
      padding-bottom: var(--spacing-sm);
      border-bottom: 1px solid var(--border-light);
    }

    .panel-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
    }

    .btn-close {
      width: 32px;
      height: 32px;
      padding: 0;
      border-radius: 50%;
      background: transparent;
      border: 1px solid var(--border-light);
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    .btn-close:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    /* Chart Container */
    .chart-container {
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
      margin-bottom: var(--spacing-md);
    }

    /* Floating Action Buttons */
    .fab-container {
      position: absolute;
      top: var(--spacing-lg);
      right: var(--spacing-lg);
      z-index: 600;
      display: flex;
      gap: var(--spacing-sm);
    }

    .fab {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: var(--bg-glass);
      backdrop-filter: var(--bg-blur);
      border: 1px solid var(--border-glass);
      box-shadow: var(--shadow-glass), var(--shadow-lg);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all var(--transition-smooth);
      font-size: 1rem;
      font-weight: 600;
      color: var(--color-primary);
      position: relative;
      overflow: hidden;
    }

    .fab::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: conic-gradient(from 0deg, transparent, var(--color-primary-light), transparent);
      opacity: 0;
      transition: opacity var(--transition-smooth);
      animation: rotate 4s linear infinite;
    }

    @keyframes rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .fab:hover::before {
      opacity: 0.15;
    }

    .fab:hover {
      background: var(--gradient-primary);
      color: var(--text-inverse);
      transform: translateY(-3px) scale(1.05);
      box-shadow: var(--shadow-glass), var(--shadow-2xl);
      border-color: var(--color-primary);
    }

    /* Timeline Controls */
    .timeline-controls {
      position: absolute;
      bottom: var(--spacing-lg);
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-overlay);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-lg);
      padding: var(--spacing-md);
      box-shadow: var(--shadow-lg);
      display: none;
      min-width: 400px;
      z-index: 600;
    }

    .timeline-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--spacing-md);
    }

    .timeline-slider {
      width: 100%;
      margin: var(--spacing-sm) 0;
    }

    .timeline-time {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-primary);
      text-align: center;
    }

    /* Responsive Design */
    @media (max-width: 1024px) {
      .legend {
        bottom: var(--spacing-sm);
        right: var(--spacing-sm);
        max-width: 240px;
      }

      .stats-panel {
        width: 300px;
        right: var(--spacing-sm);
      }

      .fab-container {
        top: var(--spacing-sm);
        right: var(--spacing-sm);
      }
    }

    @media (max-width: 768px) {
      header {
        padding: var(--spacing-sm) var(--spacing-md);
      }

      .header-title {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--spacing-sm);
      }

      h1 {
        font-size: 1.25rem;
      }

      .header-subtitle {
        font-size: 0.8rem;
        margin-bottom: var(--spacing-sm);
      }

      .controls {
        grid-template-columns: 1fr;
        gap: var(--spacing-sm);
      }

      .control-group {
        padding: var(--spacing-sm) var(--spacing-md);
      }

      .button-group {
        justify-content: stretch;
        flex-direction: column;
      }

      .button-group button {
        flex: 1;
        min-width: 0;
        padding: 12px 16px;
        font-size: 0.9rem;
        min-height: 44px; /* Better touch target */
      }

      /* Enhanced mobile form elements */
      input[type="text"],
      input[type="number"],
      select {
        padding: 12px 16px;
        font-size: 16px; /* Prevents zoom on iOS */
        min-height: 44px;
        border-radius: var(--radius-md);
      }

      .stats-panel {
        width: calc(100vw - 2 * var(--spacing-sm));
        right: var(--spacing-sm);
        left: var(--spacing-sm);
        max-height: 60vh;
        overflow-y: auto;
      }

      .timeline-controls {
        min-width: calc(100vw - 2 * var(--spacing-sm));
        left: var(--spacing-sm);
        right: var(--spacing-sm);
        transform: none;
        padding: var(--spacing-md);
      }

      .fab-container {
        flex-direction: column;
        bottom: calc(var(--spacing-lg) + 60px); /* Account for mobile browser bars */
      }

      .fab {
        width: 48px;
        height: 48px;
        font-size: 1.1rem;
      }

      .legend {
        bottom: var(--spacing-sm);
        right: var(--spacing-sm);
        left: var(--spacing-sm);
        max-width: none;
        width: calc(100vw - 2 * var(--spacing-sm));
      }

      /* Mobile popup improvements */
      .leaflet-popup-content-wrapper {
        max-width: calc(100vw - 40px) !important;
        border-radius: var(--radius-lg) !important;
      }

      .leaflet-popup-content {
        font-size: 0.875rem !important;
        line-height: 1.5 !important;
        margin: var(--spacing-md) !important;
      }
    }

    /* Small mobile devices */
    @media (max-width: 480px) {
      .header-content {
        padding: 0;
      }

      h1 {
        font-size: 1.1rem;
      }

      .header-subtitle {
        font-size: 0.75rem;
      }

      .control-group {
        padding: var(--spacing-sm);
      }

      .button-group button {
        font-size: 0.85rem;
        padding: 10px 12px;
      }
    }

    /* Map Marker Animations */
    .crime-marker {
      transition: all var(--transition-fast);
    }

    .crime-marker:hover {
      transform: scale(1.1);
    }

    .exact-location {
      animation: pulseExact 2s infinite;
    }

    .approximate-location {
      animation: pulseApprox 3s infinite;
    }

    @keyframes pulseExact {
      0%, 100% { opacity: 0.9; }
      50% { opacity: 1; }
    }

    @keyframes pulseApprox {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 0.85; }
    }

    /* Enhanced Animations & Micro-interactions */
    @keyframes slideInFromBottom {
      from {
        transform: translateY(30px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    @keyframes slideInFromRight {
      from {
        transform: translateX(30px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideInFromLeft {
      from {
        transform: translateX(-30px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes scaleIn {
      from {
        transform: scale(0.9);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }
      100% {
        transform: translateX(100%);
      }
    }

    @keyframes glow {
      0%, 100% {
        box-shadow: var(--shadow-glass), 0 0 5px var(--color-primary-light);
      }
      50% {
        box-shadow: var(--shadow-glass), 0 0 20px var(--color-primary-light), 0 0 30px var(--color-primary-light);
      }
    }

    /* Apply animations to elements */
    .control-group {
      animation: slideInFromLeft 0.4s var(--transition-ease) forwards;
    }

    .control-group:nth-child(even) {
      animation: slideInFromRight 0.4s var(--transition-ease) forwards;
    }

    .floating-panel {
      animation: scaleIn 0.3s var(--transition-ease) forwards;
    }

    .legend {
      animation: slideInFromBottom 0.4s var(--transition-ease) forwards;
    }

    .fab {
      animation: scaleIn 0.3s var(--transition-ease) forwards;
    }

    .fab:nth-child(even) {
      animation-delay: 0.1s;
    }

    .fab:nth-child(odd) {
      animation-delay: 0.05s;
    }

    button:active {
      transform: scale(0.98);
    }

    input:focus,
    select:focus {
      animation: glow 2s infinite;
    }

    /* Enhanced hover states */
    .control-group:hover .control-label {
      color: var(--color-primary);
      transform: translateY(-1px);
      transition: all var(--transition-smooth);
    }

    /* Loading shimmer effect */
    .loading-shimmer {
      position: relative;
      overflow: hidden;
    }

    .loading-shimmer::after {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shimmer 2s infinite;
      content: '';
    }

    /* Staggered animations for lists */
    .stagger-animation {
      animation: slideInFromBottom 0.4s var(--transition-ease) forwards;
    }

    .stagger-animation:nth-child(1) { animation-delay: 0.1s; }
    .stagger-animation:nth-child(2) { animation-delay: 0.2s; }
    .stagger-animation:nth-child(3) { animation-delay: 0.3s; }
    .stagger-animation:nth-child(4) { animation-delay: 0.4s; }
    .stagger-animation:nth-child(5) { animation-delay: 0.5s; }

    /* Custom Leaflet Popup Styling - Glassmorphism */
    .leaflet-popup-content-wrapper {
      background: var(--bg-glass);
      backdrop-filter: var(--bg-blur);
      border-radius: var(--border-radius-lg);
      box-shadow: var(--shadow-glass), var(--shadow-xl);
      border: 1px solid var(--border-glass);
      animation: scaleIn 0.2s var(--transition-ease) forwards;
    }

    .leaflet-popup-content-wrapper::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--gradient-primary);
      border-radius: var(--border-radius-lg) var(--border-radius-lg) 0 0;
      opacity: 0.8;
    }

    .leaflet-popup-content {
      margin: 0;
      font-family: inherit;
      font-size: 0.875rem;
      line-height: 1.5;
      color: var(--text-primary);
      position: relative;
    }

    .leaflet-popup-tip {
      background: var(--bg-glass);
      border: 1px solid var(--border-glass);
      border-top: none;
      border-right: none;
    }

    /* Accessibility */
    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* Focus Styles */
    button:focus-visible,
    input:focus-visible,
    select:focus-visible {
      outline: 2px solid var(--color-primary);
      outline-offset: 2px;
    }

    /* Print Styles */
    @media print {
      .floating-panel,
      .fab-container,
      .timeline-controls,
      .toast {
        display: none !important;
      }

      header {
        position: static;
        box-shadow: none;
      }
    }
  </style>
</head>

<body>
  <div id="app">
    <header>
      <div class="header-content">
        <div class="header-title">
          <div>
            <h1>Polishändelser Sverige</h1>
            <p class="header-subtitle">Interaktiv realtidskarta med de senaste polishändelserna och alla polisstationer</p>
          </div>
          <div style="display: flex; gap: var(--spacing-md); align-items: center;">
            <div class="status-indicator">
              <div class="status-dot"></div>
              <span>Live-data</span>
            </div>
            <div class="sync-status-indicator" id="sync-status" style="display: flex; align-items: center; gap: var(--spacing-xs); font-size: 0.75rem; color: var(--text-muted);">
              <div class="sync-dot" style="width: 6px; height: 6px; background: var(--color-primary); border-radius: 50%; animation: pulse 2s infinite;"></div>
              <span>Synkroniserar...</span>
            </div>
          </div>
        </div>

        <div class="controls">
          <div class="control-group">
            <label class="control-label" for="max-events">Max händelser</label>
            <input
              id="max-events"
              type="number"
              min="50"
              max="1000"
              value="500"
              step="50"
              aria-label="Maximalt antal händelser att visa"
            >
          </div>

          <div class="control-group">
            <label class="control-label" for="event-type">Händelsetyp</label>
            <select id="event-type" multiple aria-label="Filtrera efter händelsetyp">
              <!-- Dynamically populated -->
            </select>
          </div>

          <div class="control-group">
            <label class="control-label" for="search-query">Sök händelser</label>
            <input
              id="search-query"
              type="text"
              placeholder="Sök efter plats, typ eller beskrivning..."
              aria-label="Sök händelser"
            >
          </div>

          <div class="control-group">
            <label class="control-label" for="date-from">Datumfilter</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--spacing-xs);">
              <input
                id="date-from"
                type="date"
                aria-label="Från datum"
                style="font-size: 0.8rem;"
              >
              <input
                id="date-to"
                type="date"
                aria-label="Till datum"
                style="font-size: 0.8rem;"
              >
            </div>
          </div>

          <div class="control-group">
            <label class="control-label" for="location-search">Platsfilter</label>
            <div style="display: flex; gap: var(--spacing-xs);">
              <input
                id="location-search"
                type="text"
                placeholder="Plats eller postnummer..."
                aria-label="Sök efter plats"
                style="flex: 1;"
              >
              <select id="distance-radius" aria-label="Välj radie" style="width: 100px; font-size: 0.8rem;">
                <option value="5">5 km</option>
                <option value="10" selected>10 km</option>
                <option value="25">25 km</option>
                <option value="50">50 km</option>
                <option value="100">100 km</option>
              </select>
            </div>
            <div style="margin-top: var(--spacing-xs);">
              <button id="use-current-location" class="btn-secondary" style="font-size: 0.75rem; padding: 6px 12px;">
                📍 Använd min position
              </button>
            </div>
          </div>

          <div class="control-group">
            <label class="control-label">Snabbfilter</label>
            <div class="button-group" style="flex-wrap: wrap;">
              <button id="filter-today" class="btn-secondary" style="font-size: 0.75rem; padding: 6px 12px;">
                Idag
              </button>
              <button id="filter-week" class="btn-secondary" style="font-size: 0.75rem; padding: 6px 12px;">
                Denna vecka
              </button>
              <button id="filter-high-priority" class="btn-secondary" style="font-size: 0.75rem; padding: 6px 12px;">
                Högprioriterade
              </button>
              <button id="filter-clear" class="btn-secondary" style="font-size: 0.75rem; padding: 6px 12px;">
                Rensa filter
              </button>
            </div>
          </div>

          <div class="control-group">
            <label class="control-label">Visningsläge</label>
            <div class="button-group">
              <button id="view-markers" class="btn-secondary active" aria-label="Visa som markörer">
                Markörer
              </button>
              <button id="view-heatmap" class="btn-secondary" aria-label="Visa som värmekarta">
                Värmekarta
              </button>
            </div>
          </div>

          <div class="control-group">
            <label class="control-label">Funktioner</label>
            <div class="button-group">
              <button id="locate-user" class="btn-secondary" aria-label="Visa min position">
                Min position
              </button>
              <button id="favorites-toggle" class="btn-secondary" aria-label="Visa favoriter">
                ⭐ Favoriter
              </button>
              <button id="timeline-toggle" class="btn-secondary" aria-label="Visa tidslinje">
                Tidslinje
              </button>
              <button id="refresh-data" class="btn-primary" aria-label="Uppdatera data">
                Uppdatera
              </button>
            </div>
          </div>
        </div>
      </div>
    </header>

    <main id="map" role="main" aria-label="Interaktiv karta över polishändelser"></main>
  </div>

  <!-- Floating Action Buttons -->
  <div class="fab-container">
    <button class="fab" id="fullscreen-toggle" aria-label="Fullskärm" title="Fullskärmsläge">
      ⛶
    </button>
    <button
      class="fab"
      id="legend-toggle"
      aria-label="Dölj legend"
      aria-controls="legend"
      aria-expanded="true"
      title="Dölj legend"
    >
      ℹ️
    </button>
    <button class="fab" id="stats-toggle" aria-label="Statistik" title="Visa statistik">
      📊
    </button>
  </div>

  <!-- Legend -->
  <div class="legend floating-panel" id="legend">
    <h3 class="legend-title">
      Översikt
      <button
        class="btn-close"
        id="legend-close"
        aria-label="Stäng legend"
        aria-controls="legend"
        aria-expanded="true"
      >
        ×
      </button>
    </h3>
    <div class="legend-stats" id="legend-stats">
      Laddar statistik...
    </div>
    <div id="legend-items">
      <!-- Dynamically populated -->
    </div>
  </div>

  <!-- Favorites Panel -->
  <div class="favorites-panel" id="favorites-panel">
    <div class="favorites-header">
      <h3 class="favorites-title">Mina Favoriter</h3>
      <button class="btn-close" id="favorites-close" aria-label="Stäng favoritpanel">×</button>
    </div>
    <div class="favorites-content">
      <div class="favorites-tabs">
        <button class="favorites-tab active" id="tab-events" data-tab="events">
          Händelser <span id="favorites-count-events">(0)</span>
        </button>
        <button class="favorites-tab" id="tab-locations" data-tab="locations">
          Platser <span id="favorites-count-locations">(0)</span>
        </button>
      </div>
      <div id="favorites-events-content">
        <div class="favorites-empty" id="favorites-events-empty">
          <div class="favorites-empty-icon">⭐</div>
          <div>Inga sparade händelser än</div>
          <div style="font-size: 0.8rem; margin-top: var(--spacing-xs); opacity: 0.7;">
            Klicka på stjärnans ikon vid händelser för att spara dem
          </div>
        </div>
      </div>
      <div id="favorites-locations-content" style="display: none;">
        <div class="favorites-empty" id="favorites-locations-empty">
          <div class="favorites-empty-icon">📍</div>
          <div>Inga sparade platser än</div>
          <div style="font-size: 0.8rem; margin-top: var(--spacing-xs); opacity: 0.7;">
            Spara intressanta platser genom att söka efter dem
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Statistics Panel -->
  <div class="stats-panel floating-panel" id="stats-panel">
    <div class="panel-header">
      <h2 class="panel-title">Detaljerad Statistik</h2>
      <button class="btn-close" id="stats-close" aria-label="Stäng statistikpanel">×</button>
    </div>

    <div class="chart-container">
      <h4 style="margin: 0 0 16px; color: var(--text-primary);">Händelser över tid</h4>
      <canvas id="timeline-chart" width="300" height="150"></canvas>
    </div>

    <div class="chart-container">
      <h4 style="margin: 0 0 16px; color: var(--text-primary);">Typ av händelser</h4>
      <canvas id="type-chart" width="300" height="150"></canvas>
    </div>

    <div id="rss-container">
      <h4 style="margin: 0 0 16px; color: var(--text-primary);">Senaste nyheterna</h4>
      <input
        id="rss-filter"
        type="text"
        placeholder="Filtrera nyheter..."
        style="width: 100%; margin-bottom: 16px; padding: 8px 12px; border: 1px solid var(--border-medium); border-radius: var(--radius-sm);"
      >
      <div id="rss-items">
        <!-- Dynamically populated -->
      </div>
    </div>
  </div>

  <!-- Timeline Controls -->
  <div class="timeline-controls floating-panel" id="timeline-panel">
    <div class="timeline-header">
      <h3 style="margin: 0; font-size: 0.875rem; color: var(--text-primary);">Tidslinje-uppspelning</h3>
      <div style="display: flex; gap: 8px;">
        <button id="timeline-play" class="btn-secondary">Spela</button>
        <button id="timeline-pause" class="btn-secondary">Pausa</button>
        <button id="timeline-close" class="btn-close">×</button>
      </div>
    </div>
    <input
      type="range"
      id="timeline-slider"
      class="timeline-slider"
      min="0"
      max="23"
      value="0"
      aria-label="Tidslinje för timme på dagen"
    >
    <div class="timeline-time" id="timeline-time">00:00</div>
  </div>

  <!-- Toast Notifications -->
  <div class="toast" id="toast" role="alert" aria-live="polite">
    <!-- Dynamically populated -->
  </div>

  <!-- Loading Indicator -->
  <div class="loading" id="loading">
    <div class="spinner"></div>
    <div id="loading-text">Laddar data...</div>
  </div>

  <!-- Enhanced Loading Overlay -->
  <div class="loading-overlay" id="loading-overlay">
    <div class="loading-content">
      <div class="loading-spinner-modern"></div>
      <div class="loading-text" id="loading-overlay-text">Laddar polisdata...</div>
      <div class="loading-progress" id="loading-progress" style="display: none;">
        <div class="loading-progress-bar" id="loading-progress-bar"></div>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="js/enhanced-popup.js"></script>
  <script src="js/data-sync-manager.js"></script>

  <script>
    'use strict';

    // ===== UTILITY FUNCTIONS =====
    class Utils {
      // Toast notifications with better UX
      static showToast(message, duration = 3000, type = 'info') {
        const toast = document.getElementById('toast');
        const existingTimer = toast._timer;

        if (existingTimer) {
          clearTimeout(existingTimer);
        }

        toast.textContent = message;
        toast.className = `toast ${type}`;
        toast.style.display = 'block';

        toast._timer = setTimeout(() => {
          toast.style.display = 'none';
          toast._timer = null;
        }, duration);
      }

      // Loading state management
      static showLoading(text = 'Laddar...') {
        document.getElementById('loading-text').textContent = text;
        document.getElementById('loading').style.display = 'block';
      }

      static hideLoading() {
        document.getElementById('loading').style.display = 'none';
      }

      // Enhanced loading with progress
      static showLoadingOverlay(text = 'Laddar...', showProgress = false) {
        document.getElementById('loading-overlay-text').textContent = text;
        document.getElementById('loading-overlay').style.display = 'flex';

        const progressContainer = document.getElementById('loading-progress');
        const progressBar = document.getElementById('loading-progress-bar');

        if (showProgress) {
          progressContainer.style.display = 'block';
          progressBar.style.width = '0%';
        } else {
          progressContainer.style.display = 'none';
        }
      }

      static updateLoadingProgress(percentage, text = null) {
        const progressBar = document.getElementById('loading-progress-bar');
        const textElement = document.getElementById('loading-overlay-text');

        progressBar.style.width = Math.min(100, Math.max(0, percentage)) + '%';

        if (text) {
          textElement.textContent = text;
        }
      }

      static hideLoadingOverlay() {
        document.getElementById('loading-overlay').style.display = 'none';
      }

      // Skeleton screen methods
      static showSkeleton(containerId, type = 'default') {
        const container = document.getElementById(containerId);
        if (!container) return;

        const skeletonHTML = this.generateSkeletonHTML(type);
        container.innerHTML = skeletonHTML;
        container.classList.add('skeleton-container');
      }

      static hideSkeleton(containerId) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.classList.remove('skeleton-container');
        // Content will be replaced by actual data
      }

      static generateSkeletonHTML(type) {
        switch (type) {
          case 'stats':
            return `
              <div class="skeleton-stats">
                <div class="skeleton-stat">
                  <div class="skeleton skeleton-stat-value"></div>
                  <div class="skeleton skeleton-stat-label"></div>
                </div>
                <div class="skeleton-stat">
                  <div class="skeleton skeleton-stat-value"></div>
                  <div class="skeleton skeleton-stat-label"></div>
                </div>
                <div class="skeleton-stat">
                  <div class="skeleton skeleton-stat-value"></div>
                  <div class="skeleton skeleton-stat-label"></div>
                </div>
                <div class="skeleton-stat">
                  <div class="skeleton skeleton-stat-value"></div>
                  <div class="skeleton skeleton-stat-label"></div>
                </div>
              </div>
            `;

          case 'events':
            return Array.from({ length: 5 }, () => `
              <div class="skeleton-card">
                <div style="display: flex; align-items: center; margin-bottom: var(--spacing-sm);">
                  <div class="skeleton skeleton-circle"></div>
                  <div style="flex: 1;">
                    <div class="skeleton skeleton-header"></div>
                  </div>
                </div>
                <div class="skeleton skeleton-text"></div>
                <div class="skeleton skeleton-text"></div>
                <div class="skeleton skeleton-text"></div>
              </div>
            `).join('');

          case 'legend':
            return Array.from({ length: 8 }, () => `
              <div style="display: flex; align-items: center; margin-bottom: var(--spacing-xs);">
                <div class="skeleton skeleton-circle" style="width: 12px; height: 12px;"></div>
                <div class="skeleton skeleton-text" style="margin-left: var(--spacing-sm); width: 120px; height: 12px;"></div>
              </div>
            `).join('');

          default:
            return `
              <div class="skeleton-card">
                <div class="skeleton skeleton-header"></div>
                <div class="skeleton skeleton-text"></div>
                <div class="skeleton skeleton-text"></div>
                <div class="skeleton skeleton-text"></div>
              </div>
            `;
        }
      }

      // Debounce function for performance
      static debounce(func, delay) {
        let timeoutId;
        return (...args) => {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => func.apply(null, args), delay);
        };
      }

      // Throttle function for performance
      static throttle(func, delay) {
        let lastCall = 0;
        return (...args) => {
          const now = Date.now();
          if (now - lastCall >= delay) {
            lastCall = now;
            func.apply(null, args);
          }
        };
      }

      // Enhanced fetch with retry logic
      static async fetchWithRetry(url, options = {}, maxRetries = 3) {
        let lastError;

        for (let i = 0; i < maxRetries; i++) {
          try {
            const response = await fetch(url, options);

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            return response;
          } catch (error) {
            lastError = error;

            if (i < maxRetries - 1) {
              // Exponential backoff
              const delay = Math.min(1000 * Math.pow(2, i), 5000);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        }

        throw lastError;
      }

      // Safe JSON parsing
      static async safeJsonParse(response) {
        const text = await response.text();
        try {
          return JSON.parse(text);
        } catch (error) {
          throw new Error(`Invalid JSON response: ${error.message}`);
        }
      }

      // Sanitize HTML to prevent XSS
      static sanitizeHTML(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
      }

      // Format date in Swedish locale
      static formatDate(date, options = {}) {
        return new Intl.DateTimeFormat('sv-SE', {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          ...options
        }).format(date);
      }

      // Generate stable ID from object
      static generateStableId(obj) {
        const str = JSON.stringify(obj, Object.keys(obj).sort());
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32-bit integer
        }
        return `id_${Math.abs(hash).toString(36)}`;
      }
    }

    // ===== CRIME SEVERITY SYSTEM =====
    class CrimeSeveritySystem {
      static SEVERITY_MAPPING = {
        // Level 1 - Minor offenses (Muted Green)
        'Trafikbrott': { level: 1, color: '#6b7280', description: 'Trafikbrott', priority: 'low' },
        'Fortkörning': { level: 1, color: '#6b7280', description: 'Fortkörning', priority: 'low' },
        'Parkering': { level: 1, color: '#6b7280', description: 'Parkeringsbrott', priority: 'low' },
        'Ordningslagen': { level: 1, color: '#6b7280', description: 'Ordningslagen', priority: 'low' },

        // Level 2 - Property crimes (Muted Yellow-Orange)
        'Skadegörelse': { level: 2, color: '#a16207', description: 'Skadegörelse', priority: 'medium' },
        'Stöld': { level: 2, color: '#92400e', description: 'Stöld', priority: 'medium' },
        'Snatteri': { level: 2, color: '#92400e', description: 'Snatteri', priority: 'medium' },
        'Bedrägeri': { level: 2, color: '#92400e', description: 'Bedrägeri', priority: 'medium' },
        'Inbrott': { level: 2, color: '#78350f', description: 'Inbrott', priority: 'medium' },

        // Level 3 - Drug crimes and serious property crimes (Muted Orange-Red)
        'Narkotikabrott': { level: 3, color: '#a16207', description: 'Narkotikabrott', priority: 'high' },
        'Rattfylleri': { level: 3, color: '#a16207', description: 'Rattfylleri', priority: 'high' },
        'Rån': { level: 3, color: '#92400e', description: 'Rån', priority: 'high' },

        // Level 4 - Violent crimes (Muted Red)
        'Misshandel': { level: 4, color: '#7c2d12', description: 'Misshandel', priority: 'critical' },
        'Våldtäkt': { level: 4, color: '#7c2d12', description: 'Våldtäkt', priority: 'critical' },
        'Våld mot tjänsteman': { level: 4, color: '#7c2d12', description: 'Våld mot tjänsteman', priority: 'critical' },
        'Olaga hot': { level: 4, color: '#7c2d12', description: 'Olaga hot', priority: 'critical' },

        // Level 5 - Most serious crimes (Dark Muted Red)
        'Mord': { level: 5, color: '#78716c', description: 'Mord', priority: 'critical' },
        'Dråp': { level: 5, color: '#78716c', description: 'Dråp', priority: 'critical' },
        'Mordbrand': { level: 5, color: '#78716c', description: 'Mordbrand', priority: 'critical' },
        'Brand': { level: 4, color: '#7c2d12', description: 'Brand', priority: 'critical' },

        // Default
        'Övrigt': { level: 2, color: '#6b7280', description: 'Övrigt', priority: 'medium' }
      };

      static getPriorityForLevel(level) {
        if (typeof level !== 'number') return 'medium';
        if (level >= 4) return 'critical';
        if (level === 3) return 'high';
        if (level === 2) return 'medium';
        return 'low';
      }

      static ensurePriority(info = this.SEVERITY_MAPPING['Övrigt']) {
        const baseInfo = info || this.SEVERITY_MAPPING['Övrigt'];
        const priority = baseInfo.priority ?? this.getPriorityForLevel(baseInfo.level);

        return {
          ...baseInfo,
          priority
        };
      }

      static getSeverityInfo(crimeType) {
        if (!crimeType || typeof crimeType !== 'string') {
          return this.ensurePriority();
        }

        // Direct match
        if (this.SEVERITY_MAPPING[crimeType]) {
          return this.ensurePriority(this.SEVERITY_MAPPING[crimeType]);
        }

        // Fuzzy matching for similar crime types
        const lowerType = crimeType.toLowerCase();

        for (const [key, value] of Object.entries(this.SEVERITY_MAPPING)) {
          if (lowerType.includes(key.toLowerCase()) || key.toLowerCase().includes(lowerType)) {
            return this.ensurePriority(value);
          }
        }

        // Check for partial matches with common crime terms
        const crimeKeywords = {
          'stöld': this.SEVERITY_MAPPING['Stöld'],
          'inbrott': this.SEVERITY_MAPPING['Inbrott'],
          'rån': this.SEVERITY_MAPPING['Rån'],
          'misshandel': this.SEVERITY_MAPPING['Misshandel'],
          'narkotika': this.SEVERITY_MAPPING['Narkotikabrott'],
          'trafik': this.SEVERITY_MAPPING['Trafikbrott'],
          'brand': this.SEVERITY_MAPPING['Brand'],
          'våld': this.SEVERITY_MAPPING['Misshandel']
        };

        for (const [keyword, severity] of Object.entries(crimeKeywords)) {
          if (lowerType.includes(keyword)) {
            return this.ensurePriority(severity);
          }
        }

        // Default fallback
        return this.ensurePriority();
      }

      static getSeverityColor(crimeType) {
        return this.getSeverityInfo(crimeType).color;
      }

      static getSeverityLevel(crimeType) {
        return this.getSeverityInfo(crimeType).level;
      }

      static getAllSeverityLevels() {
        const levels = {};
        Object.values(this.SEVERITY_MAPPING).forEach(info => {
          if (!levels[info.level]) {
            levels[info.level] = [];
          }
          levels[info.level].push(info);
        });
        return levels;
      }
    }

    // ===== DATA MODELS =====
    class PoliceEvent {
      constructor(rawData) {
        this.id = Utils.generateStableId(rawData);
        this.rawData = rawData;
        this.parseData();
      }

      parseData() {
        const raw = this.rawData;

        // Parse coordinates
        this.parseCoordinates();

        // Parse date/time
        this.parseDateTime();

        // Extract location information
        this.parseLocation();

        // Parse event details
        this.type = raw.type || 'Okänd händelse';
        this.title = raw.name || raw.title || this.type;
        this.description = raw.summary || raw.description || '';
        this.url = raw.url || null;

        // Determine location accuracy
        this.exactLocation = this.hasExactCoordinates();

        // Get severity information
        this.severityInfo = CrimeSeveritySystem.getSeverityInfo(this.type);
      }

      parseCoordinates() {
        const raw = this.rawData;
        let lat = null, lng = null;

        // Try different coordinate formats
        if (raw.location && raw.location.gps) {
          const gps = raw.location.gps;
          if (typeof gps === 'string') {
            const coords = gps.split(',').map(c => parseFloat(c.trim()));
            if (coords.length === 2 && !isNaN(coords[0]) && !isNaN(coords[1])) {
              [lat, lng] = coords;
            }
          } else if (gps.lat && gps.lng) {
            lat = parseFloat(gps.lat);
            lng = parseFloat(gps.lng);
          }
        }

        // Validate coordinates are within Sweden's bounds
        if (lat && lng && this.isWithinSweden(lat, lng)) {
          this.lat = lat;
          this.lng = lng;
        } else {
          this.lat = null;
          this.lng = null;
        }
      }

      parseDateTime() {
        const raw = this.rawData;
        const dateStr = raw.datetime || raw.pubDate || raw.date;

        if (dateStr) {
          this.timestamp = new Date(dateStr);
          if (isNaN(this.timestamp)) {
            // Try alternative parsing
            this.timestamp = new Date();
          }
        } else {
          this.timestamp = new Date();
        }

        this.timeMs = this.timestamp.getTime();
      }

      parseLocation() {
        const raw = this.rawData;

        // Extract city/location name
        this.city = raw.location?.name || 'Okänd plats';

        // Try to extract address from description or summary
        this.address = this.extractAddress() || this.city;

        // Apply random offset if no exact location (privacy/accuracy)
        if (!this.hasExactCoordinates() && this.lat && this.lng) {
          this.applyRandomOffset();
        }
      }

      extractAddress() {
        const text = (this.description + ' ' + this.title).toLowerCase();

        // Swedish address patterns
        const patterns = [
          /(?:vid|på|i|från)\s+([A-ZÅÄÖ][a-zåäö]+(?:gatan|vägen|torget|platsen|parken))/i,
          /(?:vid|på|i|från)\s+([A-ZÅÄÖ][a-zåäö]+\s+\d+)/i,
          /(\w+gatan\s+\d+)/i,
          /(\w+vägen\s+\d+)/i
        ];

        for (const pattern of patterns) {
          const match = text.match(pattern);
          if (match) {
            return match[1];
          }
        }

        return null;
      }

      hasExactCoordinates() {
        const text = (this.description + ' ' + this.title).toLowerCase();

        // Indicators of exact location
        const exactIndicators = ['gatan', 'vägen', 'torget', 'platsen', 'nummer'];
        const approximateIndicators = ['området', 'närheten', 'cirka', 'ungefär'];

        const hasExact = exactIndicators.some(ind => text.includes(ind));
        const hasApproximate = approximateIndicators.some(ind => text.includes(ind));

        return hasExact && !hasApproximate;
      }

      applyRandomOffset() {
        if (!this.lat || !this.lng) return;

        // Add random offset up to ~500 meters
        const offsetLat = (Math.random() - 0.5) * 0.008; // ~0.4km
        const offsetLng = (Math.random() - 0.5) * 0.012; // ~0.4km

        this.lat += offsetLat;
        this.lng += offsetLng;
      }

      isWithinSweden(lat, lng) {
        // Sweden's approximate bounds
        return lat >= 55.0 && lat <= 69.1 && lng >= 10.5 && lng <= 24.2;
      }

      isValidEvent() {
        return this.lat && this.lng && this.timestamp && this.type;
      }

      getFormattedTime() {
        return Utils.formatDate(this.timestamp);
      }

      getPopupContent() {
        const severityColor = this.severityInfo.color;
        const locationAccuracy = this.exactLocation ?
          '<span style="color: var(--color-success); font-size: 0.75rem; font-weight: 500;">📍 Exakt position</span>' :
          '<span style="color: var(--color-warning); font-size: 0.75rem; font-weight: 500;">📍 Ungefärlig position</span>';

        const fullAddress = this.address !== this.city ? this.address : this.city;

        return `
          <div style="min-width: 260px; font-family: inherit; line-height: 1.5; position: relative;">
            <button
              type="button"
              class="favorite-star-btn"
              data-event-id="${Utils.sanitizeHTML(this.id)}"
              aria-label="Spara händelsen som favorit"
              aria-pressed="false"
              title="Spara som favorit"
            >☆</button>
            <h3 style="margin: 0 0 12px; color: var(--text-primary); font-size: 1rem; border-bottom: 2px solid ${severityColor}; padding-bottom: 6px;">
              ${Utils.sanitizeHTML(this.title)}
            </h3>

            <div style="margin: 8px 0; padding: 8px 12px; background: var(--bg-tertiary); border-left: 3px solid ${severityColor}; border-radius: 4px;">
              <strong style="color: var(--text-primary); font-size: 0.875rem;">
                ${Utils.sanitizeHTML(this.severityInfo.description)}
              </strong>
            </div>

            <div style="margin: 12px 0;">
              <strong style="color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em;">
                Plats:
              </strong><br/>
              <span style="color: var(--text-primary); font-size: 0.875rem;">
                ${Utils.sanitizeHTML(fullAddress)}
              </span><br/>
              ${locationAccuracy}
            </div>

            <div style="margin: 12px 0;">
              <strong style="color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em;">
                Tid:
              </strong><br/>
              <span style="color: var(--text-primary); font-size: 0.875rem;">
                ${this.getFormattedTime()}
              </span>
            </div>

            ${this.description ? `
              <div style="margin: 12px 0; padding-top: 8px; border-top: 1px solid var(--border-light);">
                <div style="color: var(--text-secondary); font-size: 0.8rem;">
                  ${Utils.sanitizeHTML(this.description)}
                </div>
              </div>
            ` : ''}

            ${this.url ? `
              <div style="margin: 12px 0; padding-top: 8px; border-top: 1px solid var(--border-light);">
                <a href="${this.url}" target="_blank" style="color: var(--color-primary); text-decoration: none; font-size: 0.875rem; font-weight: 500;">
                  Mer information →
                </a>
              </div>
            ` : ''}
          </div>
        `;
      }
    }

    class PoliceStation {
      constructor(rawData) {
        this.id = Utils.generateStableId(rawData);
        this.rawData = rawData;
        this.parseData();
      }

      parseData() {
        const raw = this.rawData;

        this.name = raw.name || 'Polisstation';
        this.parseCoordinates();
        this.parseContactInfo();
        this.parseServices();
      }

      parseCoordinates() {
        const raw = this.rawData;
        let lat = null, lng = null;

        const location = raw.location;
        if (location) {
          const gps = location.gps || location.position || location.coordinates;

          if (typeof gps === 'string') {
            const coords = gps.split(',').map(c => parseFloat(c.trim()));
            if (coords.length === 2 && !isNaN(coords[0]) && !isNaN(coords[1])) {
              [lat, lng] = coords;
            }
          } else if (gps && typeof gps === 'object') {
            lat = gps.lat || gps.y;
            lng = gps.lng || gps.lon || gps.x;
          }
        }

        this.lat = lat;
        this.lng = lng;
      }

      parseContactInfo() {
        const raw = this.rawData;

        this.address = raw.location?.name || raw.location?.address || 'Adress ej tillgänglig';
        this.phone = raw.phone || raw.contact?.phone || '';
        this.email = raw.email || raw.contact?.email || '';
        this.website = raw.url || raw.Url || raw.location?.url || null;
        this.openingHours = raw.openingHours || raw.hours || '';
      }

      parseServices() {
        const raw = this.rawData;
        this.services = Array.isArray(raw.services) ? raw.services : [];
        this.servicesText = this.services.length > 0 ? this.services.join(', ') : 'Allmänna polistjänster';
      }

      isValidStation() {
        return this.lat && this.lng && this.name;
      }

      createMarker() {
        if (!this.isValidStation()) return null;

        const icon = L.divIcon({
          className: 'police-station-icon',
          html: '<div style="background: var(--color-secondary); border: 2px solid white; border-radius: 50%; width: 10px; height: 10px; box-shadow: var(--shadow-sm);"></div>',
          iconSize: [10, 10],
          iconAnchor: [5, 5]
        });

        const marker = L.marker([this.lat, this.lng], {
          icon: icon,
          zIndexOffset: 100 // Below crime events
        });

        marker.bindPopup(this.getPopupContent(), {
          maxWidth: 320,
          className: 'police-station-popup'
        });

        return marker;
      }

      getPopupContent() {
        return `
          <div style="min-width: 240px; font-family: inherit; line-height: 1.5;">
            <h3 style="margin: 0 0 12px; color: var(--text-primary); font-size: 1rem; border-bottom: 2px solid var(--color-primary); padding-bottom: 6px;">
              🏢 ${Utils.sanitizeHTML(this.name)}
            </h3>

            <div style="margin: 12px 0;">
              <strong style="color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em;">
                Adress:
              </strong><br/>
              <span style="color: var(--text-primary); font-size: 0.875rem;">
                ${Utils.sanitizeHTML(this.address)}
              </span>
            </div>

            <div style="margin: 12px 0;">
              <strong style="color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em;">
                Tjänster:
              </strong><br/>
              <span style="color: var(--text-primary); font-size: 0.875rem;">
                ${Utils.sanitizeHTML(this.servicesText)}
              </span>
            </div>

            ${this.phone ? `
              <div style="margin: 12px 0;">
                <strong style="color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em;">
                  Telefon:
                </strong><br/>
                <a href="tel:${this.phone}" style="color: var(--color-primary); text-decoration: none; font-size: 0.875rem;">
                  📞 ${this.phone}
                </a>
              </div>
            ` : ''}

            ${this.email ? `
              <div style="margin: 12px 0;">
                <strong style="color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em;">
                  E-post:
                </strong><br/>
                <a href="mailto:${this.email}" style="color: var(--color-primary); text-decoration: none; font-size: 0.875rem;">
                  ✉️ ${this.email}
                </a>
              </div>
            ` : ''}

            ${this.openingHours ? `
              <div style="margin: 12px 0;">
                <strong style="color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em;">
                  Öppettider:
                </strong><br/>
                <span style="color: var(--text-primary); font-size: 0.875rem;">
                  ${Utils.sanitizeHTML(this.openingHours)}
                </span>
              </div>
            ` : ''}

            ${this.website ? `
              <div style="margin: 12px 0; padding-top: 8px; border-top: 1px solid var(--border-light);">
                <a href="${this.website}" target="_blank" style="color: var(--color-primary); text-decoration: none; font-size: 0.875rem; font-weight: 500;">
                  🌐 Mer information →
                </a>
              </div>
            ` : ''}
          </div>
        `;
      }
    }

    // ===== DATA STORAGE =====
    class DataStorage {
      static DB_NAME = 'PoliceEventsDB';
      static DB_VERSION = 2;
      static EVENTS_STORE = 'events';
      static STATIONS_STORE = 'stations';
      static FAVORITES_STORE = 'favorites';

      static db = null;

      static async initialize() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

          request.onerror = () => reject(request.error);
          request.onsuccess = () => {
            this.db = request.result;
            resolve();
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;

            // Events store
            if (!db.objectStoreNames.contains(this.EVENTS_STORE)) {
              const eventsStore = db.createObjectStore(this.EVENTS_STORE, { keyPath: 'id' });
              eventsStore.createIndex('timestamp', 'timeMs');
              eventsStore.createIndex('type', 'type');
              eventsStore.createIndex('city', 'city');
            }

            // Stations store
            if (!db.objectStoreNames.contains(this.STATIONS_STORE)) {
              const stationsStore = db.createObjectStore(this.STATIONS_STORE, { keyPath: 'id' });
            }

            // Favorites store
            if (!db.objectStoreNames.contains(this.FAVORITES_STORE)) {
              const favoritesStore = db.createObjectStore(this.FAVORITES_STORE, { keyPath: 'id' });
              favoritesStore.createIndex('type', 'type'); // 'event' or 'location'
              favoritesStore.createIndex('timestamp', 'savedAt');
            }
          };
        });
      }

      static async saveEvents(events) {
        if (!this.db) await this.initialize();

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.EVENTS_STORE], 'readwrite');
          const store = transaction.objectStore(this.EVENTS_STORE);

          transaction.onerror = () => reject(transaction.error);
          transaction.oncomplete = () => resolve();

          events.forEach(event => {
            const severityInfo = CrimeSeveritySystem.ensurePriority(event.severityInfo);
            const eventData = {
              id: event.id,
              timeMs: event.timeMs,
              timestamp: event.timestamp,
              type: event.type,
              title: event.title,
              description: event.description,
              city: event.city,
              address: event.address,
              lat: event.lat,
              lng: event.lng,
              exactLocation: event.exactLocation,
              severityInfo: { ...severityInfo },
              url: event.url
            };
            store.put(eventData);
          });
        });
      }

      static async getRecentEvents(maxAge = 7 * 24 * 60 * 60 * 1000) { // 7 days
        if (!this.db) await this.initialize();

        const cutoff = Date.now() - maxAge;

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.EVENTS_STORE], 'readonly');
          const store = transaction.objectStore(this.EVENTS_STORE);
          const index = store.index('timestamp');

          const range = IDBKeyRange.lowerBound(cutoff);
          const request = index.getAll(range);

          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result || []);
        });
      }

      static async saveStations(stations) {
        if (!this.db) await this.initialize();

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.STATIONS_STORE], 'readwrite');
          const store = transaction.objectStore(this.STATIONS_STORE);

          transaction.onerror = () => reject(transaction.error);
          transaction.oncomplete = () => resolve();

          stations.forEach(station => {
            const stationData = {
              id: station.id,
              name: station.name,
              lat: station.lat,
              lng: station.lng,
              address: station.address,
              phone: station.phone,
              email: station.email,
              website: station.website,
              services: station.services,
              servicesText: station.servicesText,
              openingHours: station.openingHours
            };
            store.put(stationData);
          });
        });
      }

      static async getAllStations() {
        if (!this.db) await this.initialize();

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.STATIONS_STORE], 'readonly');
          const store = transaction.objectStore(this.STATIONS_STORE);
          const request = store.getAll();

          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result || []);
        });
      }

      // Favorites management
      static async saveFavorite(item) {
        if (!this.db) await this.initialize();

        const favoriteItem = {
          id: item.type === 'event' ? `event_${item.id}` : `location_${Date.now()}`,
          type: item.type, // 'event' or 'location'
          data: item,
          savedAt: new Date().toISOString()
        };

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.FAVORITES_STORE], 'readwrite');
          const store = transaction.objectStore(this.FAVORITES_STORE);

          const request = store.put(favoriteItem);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(favoriteItem);
        });
      }

      static async getFavorites(type = null) {
        if (!this.db) await this.initialize();

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.FAVORITES_STORE], 'readonly');
          const store = transaction.objectStore(this.FAVORITES_STORE);

          const request = type ? store.index('type').getAll(type) : store.getAll();
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result || []);
        });
      }

      static async removeFavorite(id) {
        if (!this.db) await this.initialize();

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.FAVORITES_STORE], 'readwrite');
          const store = transaction.objectStore(this.FAVORITES_STORE);

          const request = store.delete(id);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve();
        });
      }

      static async isFavorite(id, type) {
        const favoriteId = `${type}_${id}`;
        const favorites = await this.getFavorites(type);
        return favorites.some(fav => fav.id === favoriteId);
      }
    }

    // ===== MAIN APPLICATION =====
    class PoliceEventsApp {
      constructor() {
        this.state = {
          events: [],
          allEvents: [],
          filteredEvents: [],
          stations: [],
          currentView: 'markers', // 'markers' | 'heatmap'
          maxEvents: 500,
          filters: {
            types: [],
            searchQuery: '',
            timelineHour: null,
            dateFrom: null,
            dateTo: null,
            locationCenter: null,
            locationRadius: 10,
            priorityFilter: null
          },
          map: null,
          layers: {
            eventCluster: null,
            stationCluster: null,
            heatLayer: null,
            locationCircle: null
          },
          ui: {
            loading: false,
            legendVisible: true,
            statsVisible: false,
            timelineVisible: false,
            favoritesVisible: false,
            favoritesActiveTab: 'events',
            timeline: {
              playing: false,
              currentHour: 0,
              timer: null
            }
          },
          favorites: {
            events: [],
            locations: []
          },
          userLocation: null,
          charts: {
            timeline: null,
            types: null
          },
          missingLocationCount: 0
        };

        this.initialize();
      }

      async initialize() {
        try {
          // Initialize storage
          await DataStorage.initialize();

          // Load stored favorites before rendering UI
          await this.initializeFavorites();

          // Initialize map first
          this.initializeMap();

          // Bind event listeners
          this.bindEventListeners();

          // Ensure legend visibility controls are in sync with state
          this.setLegendVisibility(this.state.ui.legendVisible);

          // Load initial data and show immediately
          await this.loadInitialData();

          // Force immediate map update
          this.renderEvents();
          this.updateUI();

          Utils.showToast('Kartan har laddats framgångsrikt', 3000, 'success');
        } catch (error) {
          console.error('Initialization error:', error);
          Utils.showToast('Fel vid initialisering av kartan', 5000, 'error');
        }
      }

      async initializeFavorites() {
        try {
          const [eventFavorites, locationFavorites] = await Promise.all([
            DataStorage.getFavorites('event'),
            DataStorage.getFavorites('location')
          ]);

          const sortBySavedAt = (a, b) => {
            const aTime = a?.savedAt ? new Date(a.savedAt).getTime() : 0;
            const bTime = b?.savedAt ? new Date(b.savedAt).getTime() : 0;
            return bTime - aTime;
          };

          this.state.favorites.events = (eventFavorites || []).sort(sortBySavedAt);
          this.state.favorites.locations = (locationFavorites || []).sort(sortBySavedAt);

          this.refreshFavoritesUI();
        } catch (error) {
          console.error('Failed to load favorites:', error);
        }
      }

      refreshFavoritesUI() {
        const eventsContainer = document.getElementById('favorites-events-content');
        const eventsEmpty = document.getElementById('favorites-events-empty');
        const locationsContainer = document.getElementById('favorites-locations-content');
        const locationsEmpty = document.getElementById('favorites-locations-empty');

        if (!eventsContainer || !locationsContainer) {
          return;
        }

        const ensureListContainer = (container, listId) => {
          let listEl = container.querySelector(`#${listId}`);
          if (!listEl) {
            listEl = document.createElement('div');
            listEl.id = listId;
            listEl.style.display = 'flex';
            listEl.style.flexDirection = 'column';
            listEl.style.gap = 'var(--spacing-sm)';
            container.appendChild(listEl);
          }
          return listEl;
        };

        const renderFavorites = (listEl, emptyEl, favorites) => {
          if (!listEl || !emptyEl) return;

          listEl.innerHTML = '';

          if (!favorites || favorites.length === 0) {
            emptyEl.style.display = 'block';
            listEl.style.display = 'none';
            return;
          }

          emptyEl.style.display = 'none';
          listEl.style.display = 'flex';

          favorites.forEach(favorite => {
            const itemEl = this.createFavoriteItemElement(favorite);
            if (itemEl) {
              listEl.appendChild(itemEl);
            }
          });
        };

        const sortedEvents = [...(this.state.favorites.events || [])].sort((a, b) => {
          const aTime = a?.savedAt ? new Date(a.savedAt).getTime() : 0;
          const bTime = b?.savedAt ? new Date(b.savedAt).getTime() : 0;
          return bTime - aTime;
        });

        const sortedLocations = [...(this.state.favorites.locations || [])].sort((a, b) => {
          const aTime = a?.savedAt ? new Date(a.savedAt).getTime() : 0;
          const bTime = b?.savedAt ? new Date(b.savedAt).getTime() : 0;
          return bTime - aTime;
        });

        const eventsList = ensureListContainer(eventsContainer, 'favorites-events-list');
        const locationsList = ensureListContainer(locationsContainer, 'favorites-locations-list');

        renderFavorites(eventsList, eventsEmpty, sortedEvents);
        renderFavorites(locationsList, locationsEmpty, sortedLocations);

        this.updateFavoritesCounts();
      }

      updateFavoritesCounts() {
        const eventsCount = document.getElementById('favorites-count-events');
        const locationsCount = document.getElementById('favorites-count-locations');

        if (eventsCount) {
          eventsCount.textContent = `(${this.state.favorites.events.length})`;
        }

        if (locationsCount) {
          locationsCount.textContent = `(${this.state.favorites.locations.length})`;
        }
      }

      createFavoriteItemElement(favorite) {
        if (!favorite || !favorite.data) {
          return null;
        }

        const data = favorite.data;
        const itemEl = document.createElement('div');
        itemEl.className = 'favorite-item';
        itemEl.dataset.favoriteId = favorite.id;

        const actionsEl = document.createElement('div');
        actionsEl.className = 'favorite-item-actions';

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'favorite-action-btn';
        removeBtn.setAttribute('aria-label', 'Ta bort favorit');
        removeBtn.textContent = '×';
        removeBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          this.removeFavorite(favorite.id);
        });

        actionsEl.appendChild(removeBtn);
        itemEl.appendChild(actionsEl);

        const header = document.createElement('div');
        header.className = 'favorite-item-header';

        const typeSpan = document.createElement('span');
        typeSpan.className = 'favorite-item-type';
        typeSpan.textContent = favorite.type === 'event'
          ? (data.eventType || 'Händelse')
          : (data.label || data.title || 'Plats');
        header.appendChild(typeSpan);

        const dateSpan = document.createElement('span');
        dateSpan.className = 'favorite-item-date';
        dateSpan.textContent = this.formatFavoriteDate(favorite);
        header.appendChild(dateSpan);

        itemEl.appendChild(header);

        const titleEl = document.createElement('div');
        titleEl.className = 'favorite-item-title';
        titleEl.textContent = data.title || data.name || 'Favorit';
        itemEl.appendChild(titleEl);

        const locationText = favorite.type === 'event'
          ? (data.address || data.city || '')
          : (data.address || data.city || data.description || '');

        if (locationText) {
          const locationEl = document.createElement('div');
          locationEl.className = 'favorite-item-location';
          locationEl.textContent = locationText;
          itemEl.appendChild(locationEl);
        }

        if (favorite.type === 'event' && data.lat && data.lng) {
          itemEl.addEventListener('click', () => {
            if (this.state.map) {
              this.state.map.setView([data.lat, data.lng], Math.max(this.state.map.getZoom(), 12));
            }
          });
        }

        return itemEl;
      }

      formatFavoriteDate(favorite) {
        if (!favorite) return '';

        const data = favorite.data || {};

        const fromTimeMs = data.timeMs ? new Date(data.timeMs) : null;
        if (fromTimeMs && !isNaN(fromTimeMs)) {
          return Utils.formatDate(fromTimeMs);
        }

        const fromTimestamp = data.timestamp
          ? (data.timestamp instanceof Date ? data.timestamp : new Date(data.timestamp))
          : null;
        if (fromTimestamp && !isNaN(fromTimestamp)) {
          return Utils.formatDate(fromTimestamp);
        }

        const fromSavedAt = favorite.savedAt ? new Date(favorite.savedAt) : null;
        if (fromSavedAt && !isNaN(fromSavedAt)) {
          return Utils.formatDate(fromSavedAt);
        }

        return 'Okänd tid';
      }

      isEventFavorited(eventId) {
        return this.state.favorites.events.some(fav => fav.id === `event_${eventId}`);
      }

      async toggleFavoriteEvent(eventData) {
        if (!eventData || !eventData.id) {
          return;
        }

        const favoriteId = `event_${eventData.id}`;

        try {
          if (this.isEventFavorited(eventData.id)) {
            await DataStorage.removeFavorite(favoriteId);
            this.state.favorites.events = this.state.favorites.events.filter(fav => fav.id !== favoriteId);
            this.refreshFavoritesUI();
            Utils.showToast('Händelsen togs bort från favoriter', 2000, 'info');
            this.updateOpenPopupFavoriteState(eventData.id);
            return false;
          }

          const favoritePayload = {
            type: 'event',
            id: eventData.id,
            title: eventData.title,
            eventType: eventData.type,
            city: eventData.city,
            address: eventData.address,
            description: eventData.description,
            url: eventData.url,
            timeMs: eventData.timeMs,
            timestamp: eventData.timestamp instanceof Date ? eventData.timestamp.toISOString() : eventData.timestamp,
            severityInfo: eventData.severityInfo,
            exactLocation: eventData.exactLocation,
            lat: eventData.lat,
            lng: eventData.lng
          };

          const savedFavorite = await DataStorage.saveFavorite(favoritePayload);

          this.state.favorites.events = [
            savedFavorite,
            ...this.state.favorites.events.filter(fav => fav.id !== savedFavorite.id)
          ];

          this.refreshFavoritesUI();
          Utils.showToast('Händelsen sparades bland favoriter', 2000, 'success');
          this.updateOpenPopupFavoriteState(eventData.id);
          return true;
        } catch (error) {
          console.error('Failed to toggle favorite event:', error);
          Utils.showToast('Kunde inte uppdatera favoriter', 3000, 'error');
          return this.isEventFavorited(eventData.id);
        }
      }

      async removeFavorite(id) {
        if (!id) return;

        try {
          await DataStorage.removeFavorite(id);

          this.state.favorites.events = this.state.favorites.events.filter(fav => fav.id !== id);
          this.state.favorites.locations = this.state.favorites.locations.filter(fav => fav.id !== id);

          this.refreshFavoritesUI();
          Utils.showToast('Favoriten togs bort', 2000, 'info');

          if (id.startsWith('event_')) {
            this.updateOpenPopupFavoriteState(id.replace('event_', ''));
          }
        } catch (error) {
          console.error('Failed to remove favorite:', error);
          Utils.showToast('Kunde inte ta bort favoriten', 3000, 'error');
        }
      }

      updateOpenPopupFavoriteState(eventId) {
        if (!eventId) return;

        const popupContent = document.querySelector('.leaflet-popup-content');
        if (!popupContent) return;

        const selectorId = typeof CSS !== 'undefined' && CSS.escape ? CSS.escape(eventId) : eventId;
        const starButton = popupContent.querySelector(`.favorite-star-btn[data-event-id="${selectorId}"]`);

        if (!starButton) {
          return;
        }

        const isFavorited = this.isEventFavorited(eventId);
        starButton.classList.toggle('favorited', isFavorited);
        starButton.setAttribute('aria-pressed', isFavorited ? 'true' : 'false');
        starButton.setAttribute('aria-label', isFavorited ? 'Ta bort händelsen från favoriter' : 'Spara händelsen som favorit');
        starButton.setAttribute('title', isFavorited ? 'Ta bort från favoriter' : 'Spara som favorit');
        starButton.textContent = isFavorited ? '★' : '☆';
      }

      onPopupOpen(event) {
        const popup = event?.popup;
        const marker = popup?._source;
        const eventData = marker?._policeEventData;

        if (!popup || !eventData) {
          return;
        }

        const popupElement = popup.getElement();
        if (!popupElement) {
          return;
        }

        const starButton = popupElement.querySelector('.favorite-star-btn');
        if (!starButton) {
          return;
        }

        const eventId = eventData.id;
        starButton.dataset.eventId = eventId;

        const updateStarState = () => {
          const isFavorited = this.isEventFavorited(eventId);
          starButton.classList.toggle('favorited', isFavorited);
          starButton.setAttribute('aria-pressed', isFavorited ? 'true' : 'false');
          starButton.setAttribute('aria-label', isFavorited ? 'Ta bort händelsen från favoriter' : 'Spara händelsen som favorit');
          starButton.setAttribute('title', isFavorited ? 'Ta bort från favoriter' : 'Spara som favorit');
          starButton.textContent = isFavorited ? '★' : '☆';
        };

        updateStarState();

        starButton.onclick = async (clickEvent) => {
          clickEvent.preventDefault();
          clickEvent.stopPropagation();
          await this.toggleFavoriteEvent(eventData);
          updateStarState();
        };
      }

      initializeMap() {
        // Create map centered on Sweden
        this.state.map = L.map('map', {
          center: [62.0, 15.0],
          zoom: 5,
          zoomControl: true,
          minZoom: 4,
          maxZoom: 18
        });

        // Add tile layer with proper attribution
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 18,
          attribution: '© <a href="https://openstreetmap.org">OpenStreetMap</a> contributors'
        }).addTo(this.state.map);

        // Initialize marker clusters
        this.initializeMarkerClusters();

        // Map event listeners
        this.state.map.on('zoomend', Utils.throttle(() => {
          this.updateMarkerSizes();
        }, 150));

        this.state.map.on('moveend', Utils.throttle(() => {
          this.updateVisibleStats();
        }, 300));

        this.state.map.on('popupopen', (event) => this.onPopupOpen(event));
      }

      initializeMarkerClusters() {
        // Event cluster with reduced clustering for better individual visibility
        this.state.layers.eventCluster = L.markerClusterGroup({
          chunkedLoading: true,
          maxClusterRadius: 25, // Reduced clustering
          disableClusteringAtZoom: 11, // Show individual markers earlier
          spiderfyOnMaxZoom: true,
          showCoverageOnHover: false,
          zoomToBoundsOnClick: true,
          iconCreateFunction: (cluster) => {
            const count = cluster.getChildCount();
            const size = count < 10 ? 'small' : count < 100 ? 'medium' : 'large';

            return L.divIcon({
              html: `<div class="event-cluster-${size}" style="
                background: var(--color-primary);
                color: white;
                border: 2px solid white;
                border-radius: 50%;
                width: ${size === 'small' ? '30px' : size === 'medium' ? '40px' : '50px'};
                height: ${size === 'small' ? '30px' : size === 'medium' ? '40px' : '50px'};
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: ${size === 'small' ? '12px' : size === 'medium' ? '14px' : '16px'};
                font-weight: 600;
                box-shadow: var(--shadow-md);
              ">${count}</div>`,
              className: 'event-cluster-marker',
              iconSize: [size === 'small' ? 30 : size === 'medium' ? 40 : 50, size === 'small' ? 30 : size === 'medium' ? 40 : 50]
            });
          }
        });

        // Police station cluster
        this.state.layers.stationCluster = L.markerClusterGroup({
          chunkedLoading: true,
          maxClusterRadius: 40,
          disableClusteringAtZoom: 9, // Cluster at lower zoom levels
          spiderfyOnMaxZoom: false,
          showCoverageOnHover: false,
          zoomToBoundsOnClick: true,
          iconCreateFunction: (cluster) => {
            const count = cluster.getChildCount();

            return L.divIcon({
              html: `<div style="
                background: var(--color-secondary);
                color: white;
                border: 1px solid white;
                border-radius: 50%;
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 11px;
                font-weight: 500;
                box-shadow: var(--shadow-sm);
              ">${count}</div>`,
              className: 'station-cluster-marker',
              iconSize: [24, 24]
            });
          }
        });

        // Add station cluster to map (always visible)
        this.state.layers.stationCluster.addTo(this.state.map);
      }

      bindEventListeners() {
        // Control event listeners
        document.getElementById('max-events').addEventListener('change',
          Utils.debounce(() => this.updateMaxEvents(), 300));

        document.getElementById('event-type').addEventListener('change',
          () => this.updateTypeFilter());

        document.getElementById('search-query').addEventListener('input',
          Utils.debounce(() => this.updateSearchFilter(), 300));

        // View mode buttons
        document.getElementById('view-markers').addEventListener('click',
          () => this.setViewMode('markers'));

        document.getElementById('view-heatmap').addEventListener('click',
          () => this.setViewMode('heatmap'));

        // Function buttons
        document.getElementById('locate-user').addEventListener('click',
          () => this.locateUser());

        document.getElementById('timeline-toggle').addEventListener('click',
          () => this.toggleTimeline());

        document.getElementById('refresh-data').addEventListener('click',
          () => this.refreshData());

        // Floating action buttons
        document.getElementById('fullscreen-toggle').addEventListener('click',
          () => this.toggleFullscreen());

        const legendToggle = document.getElementById('legend-toggle');
        if (legendToggle) {
          legendToggle.addEventListener('click', () => {
            if (this.state.ui.legendVisible) {
              this.hideLegend();
            } else {
              this.showLegend();
            }
          });
        }

        document.getElementById('stats-toggle').addEventListener('click',
          () => this.toggleStats());

        // Panel controls
        document.getElementById('legend-close').addEventListener('click',
          () => this.hideLegend());

        document.getElementById('stats-close').addEventListener('click',
          () => this.hideStats());

        document.getElementById('favorites-toggle').addEventListener('click',
          () => this.toggleFavorites());

        document.getElementById('favorites-close').addEventListener('click',
          () => this.hideFavorites());

        document.getElementById('tab-events').addEventListener('click',
          () => this.setFavoritesTab('events'));

        document.getElementById('tab-locations').addEventListener('click',
          () => this.setFavoritesTab('locations'));

        // Timeline controls
        document.getElementById('timeline-play').addEventListener('click',
          () => this.playTimeline());

        document.getElementById('timeline-pause').addEventListener('click',
          () => this.pauseTimeline());

        document.getElementById('timeline-close').addEventListener('click',
          () => this.hideTimeline());

        document.getElementById('timeline-slider').addEventListener('input',
          (e) => this.updateTimelineHour(parseInt(e.target.value)));

        // RSS filter
        document.getElementById('rss-filter').addEventListener('input',
          Utils.debounce(() => this.filterRSSItems(), 200));

        // Advanced filters
        document.getElementById('date-from').addEventListener('change', () => this.updateDateFilter());
        document.getElementById('date-to').addEventListener('change', () => this.updateDateFilter());
        document.getElementById('location-search').addEventListener('input',
          Utils.debounce(() => this.updateLocationFilter(), 500));
        document.getElementById('distance-radius').addEventListener('change', () => this.updateLocationFilter());
        document.getElementById('use-current-location').addEventListener('click', () => this.useCurrentLocation());

        // Quick filters
        document.getElementById('filter-today').addEventListener('click', () => this.applyQuickFilter('today'));
        document.getElementById('filter-week').addEventListener('click', () => this.applyQuickFilter('week'));
        document.getElementById('filter-high-priority').addEventListener('click', () => this.applyQuickFilter('high-priority'));
        document.getElementById('filter-clear').addEventListener('click', () => this.clearAllFilters());

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => this.handleKeyboardShortcuts(e));
      }

      async loadInitialData() {
        Utils.showLoading('Laddar polisdata...');

        try {
          // Load both events and stations in parallel
          const [eventsData, stationsData] = await Promise.allSettled([
            this.loadPoliceEvents(),
            this.loadPoliceStations()
          ]);

          if (eventsData.status === 'rejected') {
            console.error('Failed to load events:', eventsData.reason);
            Utils.showToast('Kunde inte ladda polishändelser', 4000, 'error');
          }

          if (stationsData.status === 'rejected') {
            console.error('Failed to load stations:', stationsData.reason);
            Utils.showToast('Kunde inte ladda polisstationer', 4000, 'warning');
          }

          // Load RSS feed (non-critical)
          this.loadRSSFeed().catch(error => {
            console.warn('RSS feed failed:', error);
          });

        } finally {
          Utils.hideLoading();
        }
      }

      async loadPoliceEvents() {
        try {
          // Try to load cached events first
          const cachedEvents = await DataStorage.getRecentEvents();

          let rehydratedCachedEvents = [];

          if (cachedEvents.length > 0) {
            // Recreate event objects from cached data
            rehydratedCachedEvents = cachedEvents.map(data => {
              const event = Object.create(PoliceEvent.prototype);
              Object.assign(event, data);

              if (!(event.timestamp instanceof Date)) {
                event.timestamp = event.timestamp ? new Date(event.timestamp) : new Date(event.timeMs || Date.now());
              }

              if (typeof event.timeMs !== 'number') {
                event.timeMs = event.timestamp ? event.timestamp.getTime() : Date.now();
              }

              if (typeof event.lat === 'string') {
                event.lat = parseFloat(event.lat);
              }

              if (typeof event.lng === 'string') {
                event.lng = parseFloat(event.lng);
              }

              if (!event.severityInfo) {
                event.severityInfo = CrimeSeveritySystem.getSeverityInfo(event.type);
              }

              event.rawData = event.rawData || {
                id: event.id,
                datetime: event.timestamp instanceof Date ? event.timestamp.toISOString() : event.timestamp,
                name: event.title,
                summary: event.description,
                url: event.url,
                type: event.type,
                location: {
                  name: event.city,
                  gps: Number.isFinite(event.lat) && Number.isFinite(event.lng) ? `${event.lat},${event.lng}` : null
                }
              };

              return event;
            });

            this.state.events = rehydratedCachedEvents;

            this.state.allEvents = [...this.state.events];

            // Immediately show cached events on map
            this.applyFilters();
            this.updateEventTypeSelect();
            this.renderEvents(); // Force immediate rendering
            Utils.showToast(`Laddade ${this.state.events.length} cachade händelser`, 2000, 'success');
          }

          // Fetch fresh data from API
          const response = await Utils.fetchWithRetry('https://polisen.se/api/events');
          const rawEvents = await Utils.safeJsonParse(response);

          if (!Array.isArray(rawEvents)) {
            throw new Error('Ogiltig data från Polisen API');
          }

          // Parse events
          const events = rawEvents
            .map(raw => new PoliceEvent(raw))
            .filter(event => event.isValidEvent())
            .sort((a, b) => b.timeMs - a.timeMs);

          // Merge with cached events and deduplicate
          const eventMap = new Map();

          // Add cached events first
          rehydratedCachedEvents.forEach(event => eventMap.set(event.id, event));

          // Add fresh events (will overwrite cached events with same ID)
          events.forEach(event => eventMap.set(event.id, event));

          // Convert back to array and sort
          this.state.allEvents = Array.from(eventMap.values())
            .sort((a, b) => b.timeMs - a.timeMs);

          this.state.events = this.state.allEvents.slice(0, this.state.maxEvents);

          // Cache new events
          await DataStorage.saveEvents(events);

          // Update UI immediately
          this.applyFilters();
          this.updateEventTypeSelect();
          this.renderEvents(); // Force immediate rendering of new data

          Utils.showToast(`Uppdaterade med ${this.state.events.length} polishändelser`, 2000, 'success');

        } catch (error) {
          console.error('Error loading police events:', error);
          throw error;
        }
      }

      async loadPoliceStations() {
        try {
          // Try cached stations first
          const cachedStations = await DataStorage.getAllStations();

          if (cachedStations.length > 0) {
            this.state.stations = cachedStations.map(data => {
              const station = Object.create(PoliceStation.prototype);
              return Object.assign(station, data);
            });

            this.renderStations();
            Utils.showToast(`Laddade ${this.state.stations.length} cachade polisstationer`, 2000, 'success');
          }

          // Fetch fresh data
          const response = await Utils.fetchWithRetry('https://polisen.se/api/policestations');
          const rawStations = await Utils.safeJsonParse(response);

          if (!Array.isArray(rawStations)) {
            throw new Error('Ogiltig data från Polisstationer API');
          }

          // Parse stations
          const stations = rawStations
            .map(raw => new PoliceStation(raw))
            .filter(station => station.isValidStation());

          this.state.stations = stations;

          // Cache stations
          await DataStorage.saveStations(stations);

          // Render stations
          this.renderStations();

          Utils.showToast(`Laddade ${stations.length} polisstationer`, 2000, 'success');

        } catch (error) {
          console.error('Error loading police stations:', error);
          throw error;
        }
      }

      async loadRSSFeed() {
        try {
          const rssSources = [
            'https://polisen.se/aktuellt/rss/',
            'https://api.allorigins.win/get?url=' + encodeURIComponent('https://polisen.se/aktuellt/rss/'),
            'https://polisen.se/aktuellt/handelser/rss/'
          ];

          let rssContent = '';

          for (const source of rssSources) {
            try {
              if (source.includes('allorigins')) {
                const response = await Utils.fetchWithRetry(source);
                const data = await Utils.safeJsonParse(response);
                rssContent = data.contents || '';
              } else {
                const response = await Utils.fetchWithRetry(source);
                rssContent = await response.text();
              }

              if (rssContent && rssContent.trim().length > 100) {
                break;
              }
            } catch (error) {
              console.warn(`RSS source ${source} failed:`, error);
            }
          }

          if (!rssContent || rssContent.trim().length < 100) {
            // Use fallback data for demonstration
            this.state.rssItems = [
              {
                title: 'Polisen informerar om trafiksäkerhet',
                link: '#',
                pubDate: new Date().toISOString(),
                description: 'Viktiga säkerhetsåtgärder under vinterförhållanden',
                location: 'Nationellt'
              },
              {
                title: 'Större polisinsats i centrala Stockholm',
                link: '#',
                pubDate: new Date(Date.now() - 3600000).toISOString(),
                description: 'Polisen genomför kontroller i city',
                location: 'Stockholm'
              },
              {
                title: 'Varning för telefonbedrägerier',
                link: '#',
                pubDate: new Date(Date.now() - 7200000).toISOString(),
                description: 'Ökat antal anmälningar om falska poliser',
                location: 'Nationellt'
              }
            ];
          } else {
            this.parseRSSFeed(rssContent);
          }

          this.renderRSSItems();

        } catch (error) {
          console.warn('RSS feed error:', error);
          // Fallback data already set above
        }
      }

      parseRSSFeed(xmlContent) {
        try {
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
          const items = xmlDoc.querySelectorAll('item');

          this.state.rssItems = Array.from(items).slice(0, 30).map(item => {
            const title = item.querySelector('title')?.textContent || '';
            const link = item.querySelector('link')?.textContent || '#';
            const description = item.querySelector('description')?.textContent || '';
            const pubDate = item.querySelector('pubDate')?.textContent || '';

            // Extract location from title or description
            const locationMatch = (title + ' ' + description).match(
              /(?:i|från|vid)\s+([A-ZÅÄÖ][a-zåäö]+(?:\s+[A-ZÅÄÖ][a-zåäö]+)?)/
            );
            const location = locationMatch ? locationMatch[1] : 'Okänd plats';

            return {
              title: Utils.sanitizeHTML(title),
              link,
              description: Utils.sanitizeHTML(description),
              pubDate,
              location: Utils.sanitizeHTML(location),
              formattedDate: this.formatRSSDate(pubDate)
            };
          });

        } catch (error) {
          console.error('RSS parsing error:', error);
          this.state.rssItems = [];
        }
      }

      formatRSSDate(dateString) {
        try {
          const date = new Date(dateString);
          return Utils.formatDate(date);
        } catch {
          return dateString;
        }
      }

      updateMaxEvents() {
        const input = document.getElementById('max-events');
        const value = Math.max(50, Math.min(1000, parseInt(input.value) || 500));

        input.value = value;
        this.state.maxEvents = value;

        // Re-slice events from full dataset
        this.state.events = this.state.allEvents.slice(0, value);
        this.applyFilters();
      }

      updateTypeFilter() {
        const select = document.getElementById('event-type');
        this.state.filters.types = Array.from(select.selectedOptions).map(option => option.value);
        this.applyFilters();
      }

      updateSearchFilter() {
        const input = document.getElementById('search-query');
        this.state.filters.searchQuery = input.value.toLowerCase().trim();
        this.applyFilters();
      }

      updateTimelineHour(hour) {
        this.state.filters.timelineHour = hour;
        this.state.ui.timeline.currentHour = hour;

        document.getElementById('timeline-time').textContent =
          `${String(hour).padStart(2, '0')}:00`;

        this.applyFilters();
      }

      applyFilters() {
        let filtered = [...this.state.events];
        let missingLocationCount = 0;

        // Type filter
        if (this.state.filters.types.length > 0) {
          filtered = filtered.filter(event =>
            this.state.filters.types.includes(event.type)
          );
        }

        // Search filter
        if (this.state.filters.searchQuery) {
          const query = this.state.filters.searchQuery;
          filtered = filtered.filter(event =>
            event.title.toLowerCase().includes(query) ||
            event.description.toLowerCase().includes(query) ||
            event.city.toLowerCase().includes(query) ||
            event.type.toLowerCase().includes(query)
          );
        }

        // Timeline hour filter
        if (this.state.filters.timelineHour !== null) {
          filtered = filtered.filter(event => {
            const eventHour = event.timestamp.getHours();
            return eventHour === this.state.filters.timelineHour;
          });
        }

        // Date range filter
        if (this.state.filters.dateFrom || this.state.filters.dateTo) {
          filtered = filtered.filter(event => {
            const eventDate = new Date(event.timestamp.toDateString());
            let include = true;

            if (this.state.filters.dateFrom) {
              include = include && eventDate >= this.state.filters.dateFrom;
            }

            if (this.state.filters.dateTo) {
              include = include && eventDate <= this.state.filters.dateTo;
            }

            return include;
          });
        }

        // Location proximity filter
        if (this.state.filters.locationCenter && this.state.filters.locationRadius) {
          const centerLat = this.state.filters.locationCenter.lat;
          const centerLng = this.state.filters.locationCenter.lng;
          const maxDistance = this.state.filters.locationRadius;

          filtered = filtered.filter(event => {
            if (!event.lat || !event.lng) {
              missingLocationCount++;
              return false;
            }
            const distance = this.calculateDistance(centerLat, centerLng, event.lat, event.lng);
            return distance <= maxDistance;
          });
        }

        this.state.missingLocationCount = missingLocationCount;

        // Priority filter
        if (this.state.filters.priorityFilter) {
          filtered = filtered.filter(event => {
            const severity = event.severityInfo || { priority: 'medium' };
            if (this.state.filters.priorityFilter === 'high-priority') {
              return severity.priority === 'high' || severity.priority === 'critical';
            }
            return true;
          });
        }

        this.state.filteredEvents = filtered;
        this.renderEvents();
        this.updateLegend();
        this.updateCharts();
      }

      setViewMode(mode) {
        this.state.currentView = mode;

        // Update button states
        document.getElementById('view-markers').classList.toggle('active', mode === 'markers');
        document.getElementById('view-heatmap').classList.toggle('active', mode === 'heatmap');

        this.renderEvents();
      }

      renderEvents() {
        // Clear existing event layers
        if (this.state.layers.eventCluster) {
          this.state.map.removeLayer(this.state.layers.eventCluster);
          this.state.layers.eventCluster.clearLayers();
        }

        if (this.state.layers.heatLayer) {
          this.state.map.removeLayer(this.state.layers.heatLayer);
          this.state.layers.heatLayer = null;
        }

        if (this.state.currentView === 'heatmap') {
          this.renderHeatmap();
        } else {
          this.renderMarkers();
        }
      }

      renderMarkers() {
        const zoom = this.state.map.getZoom();
        const baseRadius = Math.max(6, Math.min(14, zoom - 2));

        this.state.filteredEvents.forEach(event => {
          const severityColor = event.severityInfo.color;

          const marker = L.circleMarker([event.lat, event.lng], {
            radius: baseRadius + (event.exactLocation ? 2 : 0),
            color: '#ffffff',
            fillColor: severityColor,
            fillOpacity: event.exactLocation ? 0.9 : 0.75,
            weight: event.exactLocation ? 2 : 1.5,
            className: `crime-marker ${event.exactLocation ? 'exact-location' : 'approximate-location'}`,
            zIndexOffset: 1000 // Above police stations
          });


            maxWidth: 320,
            className: 'crime-event-popup'
          });

          marker.on('popupopen', (popupEvent) => {
            if (window.EnhancedEventPopup && typeof EnhancedEventPopup.attachPopupActions === 'function') {
              EnhancedEventPopup.attachPopupActions(popupEvent.popup, event);
            }
          });

          this.state.layers.eventCluster.addLayer(marker);
        });

        this.state.layers.eventCluster.addTo(this.state.map);
      }

      renderHeatmap() {
        const heatPoints = this.state.filteredEvents.map(event => [
          event.lat,
          event.lng,
          Math.max(0.3, event.severityInfo.level / 5) // Intensity based on severity
        ]);

        const zoom = this.state.map.getZoom();
        const radius = Math.max(15, Math.min(50, zoom * 3));

        this.state.layers.heatLayer = L.heatLayer(heatPoints, {
          radius: radius,
          blur: 20,
          maxZoom: 15,
          minOpacity: 0.4,
          gradient: {
            0.0: '#22c55e',
            0.2: '#f59e0b',
            0.4: '#f97316',
            0.6: '#dc2626',
            0.8: '#991b1b',
            1.0: '#7f1d1d'
          }
        });

        this.state.layers.heatLayer.addTo(this.state.map);
      }

      renderStations() {
        // Clear existing station markers
        this.state.layers.stationCluster.clearLayers();

        this.state.stations.forEach(station => {
          const marker = station.createMarker();
          if (marker) {
            this.state.layers.stationCluster.addLayer(marker);
          }
        });
      }

      updateEventTypeSelect() {
        const select = document.getElementById('event-type');
        const currentValues = Array.from(select.selectedOptions).map(o => o.value);

        // Get unique types and sort them
        const types = [...new Set(this.state.events.map(event => event.type))].sort();

        // Clear and rebuild options
        select.innerHTML = '';

        types.forEach(type => {
          const option = document.createElement('option');
          option.value = type;
          option.textContent = type;
          option.selected = currentValues.includes(type);
          select.appendChild(option);
        });

        // Set reasonable size
        select.size = Math.min(6, Math.max(1, types.length));
      }

      updateLegend() {
        const statsEl = document.getElementById('legend-stats');
        const itemsEl = document.getElementById('legend-items');

        const total = this.state.filteredEvents.length;
        const exactCount = this.state.filteredEvents.filter(e => e.exactLocation).length;
        const approxCount = total - exactCount;
        const missingLocationCount = this.state.missingLocationCount || 0;
        const locationFilterActive = Boolean(
          this.state.filters.locationCenter && this.state.filters.locationRadius
        );
        const missingLocationNotice = (locationFilterActive && missingLocationCount > 0)
          ? `<div style="margin-top: 8px; font-size: 0.7rem; color: var(--color-warning);">
              ⚠️ ${missingLocationCount} händelse${missingLocationCount > 1 ? 'r' : ''} saknar position och
              visas inte inom valt område
            </div>`
          : '';

        statsEl.innerHTML = `
          <div style="margin-bottom: 8px;">
            <strong>${total}</strong> filtrerade händelser visas
          </div>
          <div style="font-size: 0.7rem; color: var(--text-muted);">
            Exakt position: ${exactCount} | Ungefärlig: ${approxCount}
          </div>
          ${missingLocationNotice}
        `;

        // Count by type
        const typeCounts = {};
        this.state.filteredEvents.forEach(event => {
          typeCounts[event.type] = (typeCounts[event.type] || 0) + 1;
        });

        // Get top 6 most common types
        const topTypes = Object.entries(typeCounts)
          .sort(([,a], [,b]) => b - a)
          .slice(0, 6);

        itemsEl.innerHTML = topTypes.map(([type, count]) => {
          const color = CrimeSeveritySystem.getSeverityColor(type);
          return `
            <div class="legend-item">
              <div class="legend-dot" style="background: ${color}"></div>
              <span>${type} (${count})</span>
            </div>
          `;
        }).join('');
      }

      updateMarkerSizes() {
        if (this.state.currentView === 'markers') {
          this.renderEvents(); // Re-render with new sizes
        }
      }

      updateVisibleStats() {
        // Update any statistics that depend on current map view
        this.updateLegend();
      }

      updateCharts() {
        if (this.state.ui.statsVisible) {
          this.renderTimelineChart();
          this.renderTypeChart();
        }
      }

      renderTimelineChart() {
        const canvas = document.getElementById('timeline-chart');
        const ctx = canvas.getContext('2d');

        // Destroy existing chart
        if (this.state.charts.timeline) {
          this.state.charts.timeline.destroy();
        }

        // Group events by hour
        const hourCounts = new Array(24).fill(0);
        this.state.filteredEvents.forEach(event => {
          const hour = event.timestamp.getHours();
          hourCounts[hour]++;
        });

        this.state.charts.timeline = new Chart(ctx, {
          type: 'line',
          data: {
            labels: Array.from({length: 24}, (_, i) => `${String(i).padStart(2, '0')}:00`),
            datasets: [{
              label: 'Antal händelser',
              data: hourCounts,
              borderColor: 'var(--color-primary)',
              backgroundColor: 'rgba(30, 64, 175, 0.1)',
              borderWidth: 2,
              fill: true,
              tension: 0.4
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  precision: 0
                }
              }
            }
          }
        });
      }

      renderTypeChart() {
        const canvas = document.getElementById('type-chart');
        const ctx = canvas.getContext('2d');

        // Destroy existing chart
        if (this.state.charts.types) {
          this.state.charts.types.destroy();
        }

        // Count by type
        const typeCounts = {};
        this.state.filteredEvents.forEach(event => {
          typeCounts[event.type] = (typeCounts[event.type] || 0) + 1;
        });

        const sortedTypes = Object.entries(typeCounts)
          .sort(([,a], [,b]) => b - a)
          .slice(0, 8); // Top 8 types

        const labels = sortedTypes.map(([type]) => type);
        const data = sortedTypes.map(([,count]) => count);
        const colors = labels.map(type => CrimeSeveritySystem.getSeverityColor(type));

        this.state.charts.types = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: labels,
            datasets: [{
              data: data,
              backgroundColor: colors,
              borderWidth: 2,
              borderColor: '#ffffff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  boxWidth: 12,
                  padding: 10,
                  font: {
                    size: 11
                  }
                }
              }
            }
          }
        });
      }

      renderRSSItems() {
        const container = document.getElementById('rss-items');
        const filter = document.getElementById('rss-filter').value.toLowerCase();

        const filteredItems = (this.state.rssItems || []).filter(item => {
          if (!filter) return true;
          return item.title.toLowerCase().includes(filter) ||
                 item.description.toLowerCase().includes(filter) ||
                 item.location.toLowerCase().includes(filter);
        });

        container.innerHTML = filteredItems.map(item => `
          <div style="border-bottom: 1px solid var(--border-light); padding: 12px 0;">
            <h5 style="margin: 0 0 6px; font-size: 0.875rem;">
              <a href="${item.link}" target="_blank" style="color: var(--color-primary); text-decoration: none;">
                ${item.title}
              </a>
            </h5>
            <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">
              📍 ${item.location} • 🕒 ${item.formattedDate}
            </div>
            <div style="font-size: 0.8rem; color: var(--text-secondary);">
              ${item.description}
            </div>
          </div>
        `).join('');

        if (filteredItems.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-muted);">Inga nyheter matchar sökningen</div>';
        }
      }

      filterRSSItems() {
        this.renderRSSItems();
      }

      async locateUser() {
        if (!navigator.geolocation) {
          Utils.showToast('Geolokalisering stöds inte i denna webbläsare', 4000, 'error');
          return;
        }

        Utils.showLoading('Lokaliserar din position...');

        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(
              resolve,
              reject,
              {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 300000 // 5 minutes
              }
            );
          });

          const { latitude, longitude } = position.coords;
          this.state.userLocation = [latitude, longitude];

          // Add user location marker
          if (this.state.userLocationMarker) {
            this.state.map.removeLayer(this.state.userLocationMarker);
          }

          this.state.userLocationMarker = L.marker([latitude, longitude], {
            icon: L.divIcon({
              className: 'user-location-marker',
              html: '<div style="background: var(--color-primary); color: white; border: 3px solid white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; box-shadow: var(--shadow-md);">📍</div>',
              iconSize: [20, 20],
              iconAnchor: [10, 10]
            })
          });

          this.state.userLocationMarker.addTo(this.state.map);
          this.state.map.setView([latitude, longitude], 12);

          Utils.showToast('Position hittad! Kartan centrerad på din plats', 3000, 'success');

        } catch (error) {
          console.error('Geolocation error:', error);
          Utils.showToast('Kunde inte hämta din position. Kontrollera behörigheter', 4000, 'error');
        } finally {
          Utils.hideLoading();
        }
      }

      toggleTimeline() {
        this.state.ui.timelineVisible = !this.state.ui.timelineVisible;
        const panel = document.getElementById('timeline-panel');
        panel.style.display = this.state.ui.timelineVisible ? 'block' : 'none';

        if (this.state.ui.timelineVisible) {
          // Reset timeline state
          this.state.filters.timelineHour = null;
          this.state.ui.timeline.currentHour = 0;
          document.getElementById('timeline-slider').value = 0;
          document.getElementById('timeline-time').textContent = '00:00';
          this.applyFilters();
        } else {
          this.hideTimeline();
        }
      }

      hideTimeline() {
        this.state.ui.timelineVisible = false;
        this.state.filters.timelineHour = null;

        if (this.state.ui.timeline.playing) {
          this.pauseTimeline();
        }

        document.getElementById('timeline-panel').style.display = 'none';
        this.applyFilters();
      }

      playTimeline() {
        if (this.state.ui.timeline.playing) return;

        this.state.ui.timeline.playing = true;

        this.state.ui.timeline.timer = setInterval(() => {
          this.state.ui.timeline.currentHour = (this.state.ui.timeline.currentHour + 1) % 24;

          document.getElementById('timeline-slider').value = this.state.ui.timeline.currentHour;
          this.updateTimelineHour(this.state.ui.timeline.currentHour);

          if (this.state.ui.timeline.currentHour === 23) {
            // Auto-pause at end of day
            setTimeout(() => this.pauseTimeline(), 1000);
          }
        }, 1500); // 1.5 seconds per hour

        document.getElementById('timeline-play').textContent = 'Spelar...';
      }

      pauseTimeline() {
        if (this.state.ui.timeline.timer) {
          clearInterval(this.state.ui.timeline.timer);
          this.state.ui.timeline.timer = null;
        }

        this.state.ui.timeline.playing = false;
        document.getElementById('timeline-play').textContent = 'Spela';
      }

      toggleFavorites() {
        const panel = document.getElementById('favorites-panel');
        if (!panel) return;

        this.state.ui.favoritesVisible = !this.state.ui.favoritesVisible;
        panel.style.display = this.state.ui.favoritesVisible ? 'flex' : 'none';

        if (this.state.ui.favoritesVisible) {
          this.setFavoritesTab(this.state.ui.favoritesActiveTab);
        }
      }

      hideFavorites() {
        const panel = document.getElementById('favorites-panel');
        if (!panel) return;

        this.state.ui.favoritesVisible = false;
        panel.style.display = 'none';
      }

      setFavoritesTab(tab) {
        if (!['events', 'locations'].includes(tab)) {
          return;
        }

        this.state.ui.favoritesActiveTab = tab;

        const eventsTab = document.getElementById('tab-events');
        const locationsTab = document.getElementById('tab-locations');
        const eventsContent = document.getElementById('favorites-events-content');
        const locationsContent = document.getElementById('favorites-locations-content');

        if (eventsTab) {
          eventsTab.classList.toggle('active', tab === 'events');
        }

        if (locationsTab) {
          locationsTab.classList.toggle('active', tab === 'locations');
        }

        if (eventsContent) {
          eventsContent.style.display = tab === 'events' ? 'block' : 'none';
        }

        if (locationsContent) {
          locationsContent.style.display = tab === 'locations' ? 'block' : 'none';
        }
      }

      async refreshData() {
        Utils.showLoading('Uppdaterar data...');

        try {
          await this.loadPoliceEvents();
          await this.loadPoliceStations();
          await this.loadRSSFeed();

          Utils.showToast('Data har uppdaterats framgångsrikt', 3000, 'success');

        } catch (error) {
          console.error('Refresh error:', error);
          Utils.showToast('Ett fel uppstod vid uppdatering av data', 4000, 'error');
        } finally {
          Utils.hideLoading();
        }
      }

      toggleFullscreen() {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().then(() => {
            Utils.showToast('Fullskärmsläge aktiverat', 2000, 'success');
          }).catch(() => {
            Utils.showToast('Kunde inte aktivera fullskärm', 3000, 'error');
          });
        } else {
          document.exitFullscreen().then(() => {
            Utils.showToast('Fullskärmsläge avaktiverat', 2000, 'info');
          });
        }
      }

      toggleStats() {
        this.state.ui.statsVisible = !this.state.ui.statsVisible;
        const panel = document.getElementById('stats-panel');
        panel.style.display = this.state.ui.statsVisible ? 'block' : 'none';

        if (this.state.ui.statsVisible) {
          // Render charts when panel is shown
          setTimeout(() => {
            this.renderTimelineChart();
            this.renderTypeChart();
            this.renderRSSItems();
          }, 100);
        }
      }

      hideStats() {
        this.state.ui.statsVisible = false;
        document.getElementById('stats-panel').style.display = 'none';
      }

      setLegendVisibility(isVisible) {
        const legendEl = document.getElementById('legend');
        if (!legendEl) return;

        this.state.ui.legendVisible = isVisible;
        legendEl.style.display = isVisible ? 'block' : 'none';
        legendEl.setAttribute('aria-hidden', isVisible ? 'false' : 'true');

        const toggleButton = document.getElementById('legend-toggle');
        if (toggleButton) {
          toggleButton.setAttribute('aria-expanded', isVisible ? 'true' : 'false');
          toggleButton.setAttribute('aria-label', isVisible ? 'Dölj legend' : 'Visa legend');
          toggleButton.title = isVisible ? 'Dölj legend' : 'Visa legend';
          toggleButton.classList.toggle('active', isVisible);
        }

        const closeButton = document.getElementById('legend-close');
        if (closeButton) {
          closeButton.setAttribute('aria-expanded', isVisible ? 'true' : 'false');
        }
      }

      showLegend() {
        this.setLegendVisibility(true);
        this.updateLegend();
      }

      hideLegend() {
        this.setLegendVisibility(false);
      }

      handleKeyboardShortcuts(event) {
        // Only handle shortcuts if no input is focused
        if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT') {
          return;
        }

        switch (event.key) {
          case 'r':
          case 'R':
            event.preventDefault();
            this.refreshData();
            break;

          case 'f':
          case 'F':
            event.preventDefault();
            this.toggleFullscreen();
            break;

          case 's':
          case 'S':
            event.preventDefault();
            this.toggleStats();
            break;

          case 't':
          case 'T':
            event.preventDefault();
            this.toggleTimeline();
            break;

          case 'l':
          case 'L':
            event.preventDefault();
            this.locateUser();
            break;

          case 'm':
          case 'M':
            event.preventDefault();
            this.setViewMode(this.state.currentView === 'markers' ? 'heatmap' : 'markers');
            break;

          case 'Escape':
            event.preventDefault();
            if (this.state.ui.statsVisible) this.hideStats();
            if (this.state.ui.timelineVisible) this.hideTimeline();
            break;
        }
      }

      updateUI() {
        // Update any UI elements that need initial setup
        this.updateLegend();

        // Set up service worker for offline functionality
        this.registerServiceWorker();

        // Add keyboard shortcut info to tooltips
        this.updateTooltips();
      }

      updateTooltips() {
        const shortcuts = {
          'refresh-data': 'Uppdatera (R)',
          'fullscreen-toggle': 'Fullskärm (F)',
          'stats-toggle': 'Statistik (S)',
          'timeline-toggle': 'Tidslinje (T)',
          'locate-user': 'Min position (L)',
          'view-markers': 'Markörer (M)',
          'view-heatmap': 'Värmekarta (M)'
        };

        Object.entries(shortcuts).forEach(([id, tooltip]) => {
          const element = document.getElementById(id);
          if (element) {
            element.title = tooltip;
          }
        });
      }

      async registerServiceWorker() {
        if ('serviceWorker' in navigator) {
          try {
            await navigator.serviceWorker.register('/sw.js');
            console.log('Service Worker registered successfully');
          } catch (error) {
            console.warn('Service Worker registration failed:', error);
          }
        }
      }

      // Advanced filter methods
      updateDateFilter() {
        const dateFrom = document.getElementById('date-from').value;
        const dateTo = document.getElementById('date-to').value;

        this.state.filters.dateFrom = dateFrom ? new Date(dateFrom) : null;
        this.state.filters.dateTo = dateTo ? new Date(dateTo) : null;

        this.applyFilters();
      }

      getZoomLevelForRadius(radiusKm) {
        const numericRadius = typeof radiusKm === 'number' ? radiusKm : parseFloat(radiusKm);
        const radius = Number.isFinite(numericRadius) ? numericRadius : 10;
        if (radius <= 5) return 12;
        if (radius <= 10) return 11;
        if (radius <= 25) return 10;
        if (radius <= 50) return 9;
        if (radius <= 100) return 8;
        return 7;
      }

      updateLocationCircle(lat, lng, radiusKm) {
        if (!this.state.map) return;

        const numericRadius = typeof radiusKm === 'number' ? radiusKm : parseFloat(radiusKm);
        const safeRadiusKm = Number.isFinite(numericRadius) ? numericRadius : 0;
        const radiusMeters = Math.max(0, safeRadiusKm) * 1000;

        if (this.state.layers.locationCircle) {
          this.state.layers.locationCircle.setLatLng([lat, lng]);
          this.state.layers.locationCircle.setRadius(radiusMeters);
        } else {
          this.state.layers.locationCircle = L.circle([lat, lng], {
            radius: radiusMeters,
            color: '#2563eb',
            weight: 2,
            fillColor: '#2563eb',
            fillOpacity: 0.15
          }).addTo(this.state.map);
        }
      }

      clearLocationCircle() {
        if (this.state.layers.locationCircle && this.state.map) {
          this.state.map.removeLayer(this.state.layers.locationCircle);
        }
        this.state.layers.locationCircle = null;
      }

      updateLocationFilter() {
        const locationQuery = document.getElementById('location-search').value.trim();
        this.state.filters.locationRadius = parseInt(document.getElementById('distance-radius').value);

        if (locationQuery) {
          this.geocodeLocation(locationQuery);
        } else {
          this.state.filters.locationCenter = null;
          this.clearLocationCircle();
          this.applyFilters();
        }
      }

      async geocodeLocation(query) {
        try {
          Utils.showToast('Söker efter plats...', 1500, 'info');

          // Simple geocoding using Nominatim (OpenStreetMap)
          const response = await fetch(
            `https://nominatim.openstreetmap.org/search?format=json&country=sweden&q=${encodeURIComponent(query)}&limit=1`
          );
          const results = await response.json();

          if (results.length > 0) {
            const lat = parseFloat(results[0].lat);
            const lng = parseFloat(results[0].lon);
            this.state.filters.locationCenter = {
              lat,
              lng
            };

            if (this.state.map) {
              const radiusKm = this.state.filters.locationRadius || 10;
              const zoom = this.getZoomLevelForRadius(radiusKm);
              this.state.map.setView([lat, lng], zoom);
              this.updateLocationCircle(lat, lng, radiusKm);
            }
            Utils.showToast(`Filtrerar inom ${this.state.filters.locationRadius} km från ${results[0].display_name.split(',')[0]}`, 3000, 'success');
            this.applyFilters();
          } else {
            Utils.showToast('Kunde inte hitta platsen', 3000, 'warning');
          }
        } catch (error) {
          console.error('Geocoding failed:', error);
          Utils.showToast('Fel vid platssökning', 3000, 'error');
        }
      }

      useCurrentLocation() {
        if (!navigator.geolocation) {
          Utils.showToast('Geolokalisering stöds inte', 3000, 'error');
          return;
        }

        Utils.showToast('Hämtar din position...', 2000, 'info');

        navigator.geolocation.getCurrentPosition(
          (position) => {
            this.state.filters.locationCenter = {
              lat: position.coords.latitude,
              lng: position.coords.longitude
            };

            document.getElementById('location-search').value = `${position.coords.latitude.toFixed(4)}, ${position.coords.longitude.toFixed(4)}`;
            if (this.state.map) {
              const radiusKm = this.state.filters.locationRadius || 10;
              const zoom = this.getZoomLevelForRadius(radiusKm);
              this.state.map.setView([position.coords.latitude, position.coords.longitude], zoom);
              this.updateLocationCircle(position.coords.latitude, position.coords.longitude, radiusKm);
            }
            Utils.showToast(`Filtrerar inom ${this.state.filters.locationRadius} km från din position`, 3000, 'success');
            this.applyFilters();
          },
          (error) => {
            console.error('Geolocation error:', error);
            Utils.showToast('Kunde inte hämta din position', 3000, 'error');
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 300000
          }
        );
      }

      applyQuickFilter(type) {
        const now = new Date();

        switch (type) {
          case 'today':
            this.state.filters.dateFrom = new Date(now.toDateString());
            this.state.filters.dateTo = new Date(now.toDateString());
            document.getElementById('date-from').value = now.toISOString().split('T')[0];
            document.getElementById('date-to').value = now.toISOString().split('T')[0];
            Utils.showToast('Visar händelser från idag', 2000, 'success');
            break;

          case 'week':
            const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            this.state.filters.dateFrom = weekAgo;
            this.state.filters.dateTo = now;
            document.getElementById('date-from').value = weekAgo.toISOString().split('T')[0];
            document.getElementById('date-to').value = now.toISOString().split('T')[0];
            Utils.showToast('Visar händelser från senaste veckan', 2000, 'success');
            break;

          case 'high-priority':
            this.state.filters.priorityFilter = 'high-priority';
            Utils.showToast('Visar endast högprioriterade händelser', 2000, 'success');
            break;
        }

        // Update active button states
        document.querySelectorAll('#filter-today, #filter-week, #filter-high-priority').forEach(btn => {
          btn.classList.remove('active');
        });
        document.getElementById(`filter-${type}`).classList.add('active');

        this.applyFilters();
      }

      clearAllFilters() {
        // Reset all filters
        this.state.filters = {
          types: [],
          searchQuery: '',
          timelineHour: null,
          dateFrom: null,
          dateTo: null,
          locationCenter: null,
          locationRadius: 10,
          priorityFilter: null
        };

        // Reset form values
        document.getElementById('search-query').value = '';
        document.getElementById('date-from').value = '';
        document.getElementById('date-to').value = '';
        document.getElementById('location-search').value = '';
        document.getElementById('distance-radius').value = '10';
        document.getElementById('event-type').selectedIndex = -1;

        // Reset button states
        document.querySelectorAll('.btn-secondary.active').forEach(btn => {
          btn.classList.remove('active');
        });

        Utils.showToast('Alla filter rensade', 2000, 'success');
        this.clearLocationCircle();
        this.applyFilters();
      }

      calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Earth's radius in kilometers
        const dLat = this.deg2rad(lat2 - lat1);
        const dLon = this.deg2rad(lon2 - lon1);
        const a =
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(this.deg2rad(lat1)) * Math.cos(this.deg2rad(lat2)) *
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      }

      deg2rad(deg) {
        return deg * (Math.PI/180);
      }
    }

    // ===== APPLICATION INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        // Initialize data sync manager first
        console.log('🚀 Initializing Advanced Data Sync Manager...');
        window.dataSyncManager = new DataSyncManager();

        // Initialize the main application
        console.log('🚀 Initializing Police Events App...');
        window.policeEventsApp = new PoliceEventsApp();

        // Set up event listeners for data sync integration
        document.addEventListener('dataReady', (event) => {
          console.log('📊 Data ready event received:', event.detail);
          if (window.policeEventsApp && window.policeEventsApp.refreshDisplay) {
            window.policeEventsApp.refreshDisplay();
          }
        });

        document.addEventListener('dataUpdated', (event) => {
          console.log('🔄 Data updated event received:', event.detail);
          if (window.policeEventsApp && window.policeEventsApp.handleDataUpdate) {
            window.policeEventsApp.handleDataUpdate(event.detail.type);
          }
        });

        // Add force sync button handler
        document.getElementById('refresh-data').addEventListener('click', async () => {
          if (window.dataSyncManager) {
            await window.dataSyncManager.forceSync();
          }
        });

        console.log('✅ Application initialized successfully with advanced data sync!');

      } catch (error) {
        console.error('❌ Failed to initialize application:', error);
        Utils.showToast('Kunde inte starta applikationen - ladda om sidan', 8000, 'error');
      }

      // Global error handler
      window.addEventListener('error', (event) => {
        console.error('Global error:', event.error);
        Utils.showToast('Ett oväntat fel uppstod', 4000, 'error');
      });

      // Handle unhandled promise rejections
      window.addEventListener('unhandledrejection', (event) => {
        console.error('Unhandled promise rejection:', event.reason);
        Utils.showToast('Ett fel uppstod vid datahantering', 4000, 'error');
        event.preventDefault(); // Prevent console spam
      });

      // Add sync status indicator
      const addSyncStatusIndicator = () => {
        const statusIndicator = document.querySelector('.status-indicator');
        const syncStatusIndicator = document.getElementById('sync-status');

        if (statusIndicator && syncStatusIndicator && window.dataSyncManager) {
          const updateStatus = () => {
            const stats = window.dataSyncManager.getSyncStats();
            const statusText = statusIndicator.querySelector('span');
            const statusDot = statusIndicator.querySelector('.status-dot');
            const syncText = syncStatusIndicator.querySelector('span');
            const syncDot = syncStatusIndicator.querySelector('.sync-dot');

            // Update main connection status
            if (stats.isOnline) {
              statusText.textContent = `Ansluten • ${stats.mode} läge`;
              statusDot.style.background = 'var(--color-success)';
            } else {
              statusText.textContent = 'Offline • Lokala data';
              statusDot.style.background = 'var(--color-warning)';
            }

            // Update sync status
            const lastSyncTimes = Object.values(stats.lastSyncTimestamps);
            const mostRecentSync = Math.max(...lastSyncTimes.filter(t => t > 0));

            if (mostRecentSync > 0) {
              const minutesAgo = Math.floor((Date.now() - mostRecentSync) / 60000);
              if (minutesAgo < 1) {
                syncText.textContent = 'Precis synkad';
                syncDot.style.background = 'var(--color-success)';
                syncDot.style.animation = 'none';
              } else if (minutesAgo < 5) {
                syncText.textContent = `Synkad ${minutesAgo}m sedan`;
                syncDot.style.background = 'var(--color-success)';
                syncDot.style.animation = 'none';
              } else if (minutesAgo < 30) {
                syncText.textContent = `Synkad ${minutesAgo}m sedan`;
                syncDot.style.background = 'var(--color-warning)';
                syncDot.style.animation = 'pulse 2s infinite';
              } else {
                syncText.textContent = 'Gammal data';
                syncDot.style.background = 'var(--color-error)';
                syncDot.style.animation = 'pulse 1s infinite';
              }
            } else {
              syncText.textContent = 'Synkroniserar...';
              syncDot.style.background = 'var(--color-primary)';
              syncDot.style.animation = 'pulse 1.5s infinite';
            }
          };

          // Update immediately and then every 30 seconds
          updateStatus();
          const statusInterval = setInterval(updateStatus, 30000);

          // Update on online/offline events
          window.addEventListener('online', updateStatus);
          window.addEventListener('offline', updateStatus);

          // Update on data sync events
          document.addEventListener('dataReady', updateStatus);
          document.addEventListener('dataUpdated', updateStatus);

          // Store interval for cleanup if needed
          window.statusUpdateInterval = statusInterval;
        }
      };

      // Add status indicator after a short delay to ensure DOM is ready
      setTimeout(addSyncStatusIndicator, 1000);
    });

  </script>
</body>
</html>